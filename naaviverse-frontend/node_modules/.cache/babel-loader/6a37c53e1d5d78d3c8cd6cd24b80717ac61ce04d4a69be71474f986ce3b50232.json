{"ast":null,"code":"/* eslint-disable no-multi-spaces, key-spacing, indent, camelcase, space-before-blocks, eqeqeq, brace-style */\n/* eslint-disable space-infix-ops, space-before-function-paren, array-bracket-spacing, object-curly-spacing */\n/* eslint-disable no-nested-ternary, max-params, default-case, no-else-return, no-empty, yoda */\n/* eslint-disable no-param-reassign, no-var, block-scoped-var */\n\nimport * as geo from \"../geometry\";\nimport * as PDF from \"../pdf\";\nimport { arabicToRoman, createPromise, measureText, mergeSort } from '../util';\nimport { parseColor as utils_parseColor, support, template as compileTemplate } from \"../common\";\nimport { Path, Text, Group, Image, Circle, LinearGradient } from \"../drawing\";\nimport { encodeBase64 } from \"../util\";\nvar browser = support.browser || {};\n/*\n\n  XXX: to test:\n\n  - cloneNodes function:\n    - drawing document containing canvas with page breaking\n    - drawing document with named radio <input>-s (should not clear selection)\n    - IE9/IE10 don't support el.dataset; do they copy user data?\n\n  - repeating table headers/footers on page breaking\n\n  - forceBreak, keepTogether\n\n  - avoidLinks\n\n */\n\n/* -----[ local vars ]----- */\n\nfunction slice(thing) {\n  return Array.prototype.slice.call(thing);\n}\nvar KENDO_PSEUDO_ELEMENT = \"KENDO-PSEUDO-ELEMENT\";\nvar IMAGE_CACHE = {};\nvar nodeInfo = {};\nnodeInfo._root = nodeInfo;\n\n/* -----[ Custom Text node to speed up rendering in PDF ]----- */\n\nvar inBrowser = typeof window !== 'undefined';\nvar microsoft = inBrowser ? browser.msie || browser.edge : false;\nvar TextRect = function (Text) {\n  function TextRect(str, rect, options) {\n    Text.call(this, str, rect.getOrigin(), options);\n    this._pdfRect = rect;\n  }\n  if (Text) TextRect.__proto__ = Text;\n  TextRect.prototype = Object.create(Text && Text.prototype);\n  TextRect.prototype.constructor = TextRect;\n  TextRect.prototype.rect = function rect() {\n    // this is the crux of it: we can avoid a call to\n    // measure(), which is what the base class does, since we\n    // already know the rect.  measure() is s-l-o-w.\n    return this._pdfRect;\n  };\n  TextRect.prototype.rawBBox = function rawBBox() {\n    // also let's avoid creating a new rectangle.\n    return this._pdfRect;\n  };\n  return TextRect;\n}(Text);\nfunction addClass(el, cls) {\n  if (el.classList) {\n    el.classList.add(cls);\n  } else {\n    el.className += \" \" + cls;\n  }\n}\nfunction removeClass(el, cls) {\n  if (el.classList) {\n    el.classList.remove(cls);\n  } else {\n    el.className = el.className.split(/\\s+/).reduce(function (a, word) {\n      if (word != cls) {\n        a.push(word);\n      }\n      return a;\n    }, []).join(\" \");\n  }\n}\nfunction setCSS(el, styles) {\n  Object.keys(styles).forEach(function (key) {\n    el.style[key] = styles[key];\n  });\n}\nvar matches = typeof Element !== \"undefined\" && Element.prototype && function (p) {\n  if (p.matches) {\n    return function (el, selector) {\n      return el.matches(selector);\n    };\n  }\n  if (p.webkitMatchesSelector) {\n    return function (el, selector) {\n      return el.webkitMatchesSelector(selector);\n    };\n  }\n  if (p.mozMatchesSelector) {\n    return function (el, selector) {\n      return el.mozMatchesSelector(selector);\n    };\n  }\n  if (p.msMatchesSelector) {\n    return function (el, selector) {\n      return el.msMatchesSelector(selector);\n    };\n  }\n  return function (s) {\n    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;\n  };\n}(Element.prototype);\nfunction closest(el, selector) {\n  if (el.closest) {\n    return el.closest(selector);\n  }\n  // IE: stringifying rather than simply comparing with `document`,\n  // which is not iframe-proof and fails in editor export â€”\n  // https://github.com/telerik/kendo/issues/6721\n  while (el && !/^\\[object (?:HTML)?Document\\]$/.test(String(el))) {\n    if (el.nodeType == 1 /* Element */ && matches(el, selector)) {\n      return el;\n    }\n    el = el.parentNode;\n  }\n}\n\n// clone nodes ourselves, so that we redraw <canvas> (DOM or\n// jQuery clone will not)\nvar cloneNodes = function ($) {\n  if ($) {\n    // if we have Kendo and jQuery, use this version as it will\n    // maintain proper links between cloned element and Kendo\n    // widgets (i.e. it clones jQuery data(), which isn't the same\n    // as element's data attributes).\n    // https://github.com/telerik/kendo-ui-core/issues/2750\n    return function cloneNodes(el) {\n      var clone = el.cloneNode(false);\n      if (el.nodeType == 1 /* Element */) {\n        var $el = $(el),\n          $clone = $(clone),\n          i;\n        var data = $el.data();\n        for (i in data) {\n          $clone.data(i, data[i]);\n        }\n        if (/^canvas$/i.test(el.tagName)) {\n          clone.getContext(\"2d\").drawImage(el, 0, 0);\n        } else if (/^(?:input|select|textarea|option)$/i.test(el.tagName)) {\n          // drop the name attributes so that we don't affect the selection of the\n          // original nodes (i.e. checked status of radio buttons) when we insert our copy\n          // into the DOM.  https://github.com/telerik/kendo/issues/5409\n          clone.removeAttribute(\"id\");\n          clone.removeAttribute(\"name\");\n          if (!/^textarea$/i.test(el.tagName)) {\n            clone.value = el.value;\n          }\n          clone.checked = el.checked;\n          clone.selected = el.selected;\n        }\n        for (i = el.firstChild; i; i = i.nextSibling) {\n          clone.appendChild(cloneNodes(i));\n        }\n      }\n      return clone;\n    };\n  } else {\n    // the no-jQuery version\n    return function cloneNodes(el) {\n      var clone = function dive(node) {\n        var clone = node.cloneNode(false);\n        if (node._kendoExportVisual) {\n          clone._kendoExportVisual = node._kendoExportVisual;\n        }\n        for (var i = node.firstChild; i; i = i.nextSibling) {\n          clone.appendChild(dive(i));\n        }\n        return clone;\n      }(el);\n\n      // re-draw canvases - https://github.com/telerik/kendo/issues/4872\n      var canvases = el.querySelectorAll(\"canvas\");\n      if (canvases.length) {\n        slice(clone.querySelectorAll(\"canvas\")).forEach(function (canvas, i) {\n          canvas.getContext(\"2d\").drawImage(canvases[i], 0, 0);\n        });\n      }\n\n      // remove \"name\" attributes from <input> elements -\n      // https://github.com/telerik/kendo/issues/5409\n      var orig = el.querySelectorAll(\"input, select, textarea, option\");\n      slice(clone.querySelectorAll(\"input, select, textarea, option\")).forEach(function (el, i) {\n        el.removeAttribute(\"id\");\n        el.removeAttribute(\"name\");\n        if (!/^textarea$/i.test(el.tagName)) {\n          el.value = orig[i].value;\n        }\n        el.checked = orig[i].checked;\n        el.selected = orig[i].selected;\n      });\n      return clone;\n    };\n  }\n}(typeof window !== \"undefined\" && window.kendo && window.kendo.jQuery);\nfunction getXY(thing) {\n  if (typeof thing == \"number\") {\n    return {\n      x: thing,\n      y: thing\n    };\n  }\n  if (Array.isArray(thing)) {\n    return {\n      x: thing[0],\n      y: thing[1]\n    };\n  }\n  return {\n    x: thing.x,\n    y: thing.y\n  };\n}\nfunction drawDOM(element, options) {\n  if (!options) {\n    options = {};\n  }\n  var promise = createPromise();\n  if (!element) {\n    return promise.reject(\"No element to export\");\n  }\n  if (typeof window.getComputedStyle != \"function\") {\n    throw new Error(\"window.getComputedStyle is missing.  You are using an unsupported browser, or running in IE8 compatibility mode.  Drawing HTML is supported in Chrome, Firefox, Safari and IE9+.\");\n  }\n  PDF.defineFont(getFontFaces(element.ownerDocument));\n  var scale = getXY(options.scale || 1);\n  function doOne(element) {\n    var group = new Group();\n\n    // translate to start of page\n    var pos = element.getBoundingClientRect();\n    setTransform(group, [scale.x, 0, 0, scale.y, -pos.left * scale.x, -pos.top * scale.y]);\n    nodeInfo._clipbox = false;\n    nodeInfo._matrix = geo.Matrix.unit();\n    nodeInfo._stackingContext = {\n      element: element,\n      group: group\n    };\n    if (options.avoidLinks === true) {\n      nodeInfo._avoidLinks = \"a\";\n    } else {\n      nodeInfo._avoidLinks = options.avoidLinks;\n    }\n    addClass(element, \"k-pdf-export\");\n    renderElement(element, group);\n    removeClass(element, \"k-pdf-export\");\n    return group;\n  }\n  cacheImages([element], function () {\n    var forceBreak = options && options.forcePageBreak;\n    var hasPaperSize = options && options.paperSize && options.paperSize != \"auto\";\n    var paperOptions = PDF.getPaperOptions(function (key, def) {\n      if (key == \"paperSize\") {\n        // PDF.getPaperOptions croaks on \"auto\", just pass dummy A4 as we might\n        // still be interested in margins.\n        return hasPaperSize ? options[key] : \"A4\";\n      }\n      return key in options ? options[key] : def;\n    });\n    var pageWidth = hasPaperSize && paperOptions.paperSize[0];\n    var pageHeight = hasPaperSize && paperOptions.paperSize[1];\n    var margin = options.margin && paperOptions.margin;\n    var hasMargin = Boolean(margin);\n    if (forceBreak || pageHeight) {\n      if (!margin) {\n        margin = {\n          left: 0,\n          top: 0,\n          right: 0,\n          bottom: 0\n        };\n      }\n\n      // we want paper size and margin to be unaffected by\n      // scaling in the output, so we have to reverse-scale\n      // before our calculations begin.\n      if (pageWidth) {\n        pageWidth /= scale.x;\n      }\n      if (pageHeight) {\n        pageHeight /= scale.y;\n      }\n      margin.left /= scale.x;\n      margin.right /= scale.x;\n      margin.top /= scale.y;\n      margin.bottom /= scale.y;\n      var group = new Group({\n        pdf: {\n          multiPage: true,\n          paperSize: hasPaperSize ? paperOptions.paperSize : \"auto\",\n          _ignoreMargin: hasMargin // HACK!  see exportPDF in pdf/drawing.js\n        }\n      });\n\n      handlePageBreaks(function (x) {\n        if (options.progress) {\n          var canceled = false,\n            pageNum = 0;\n          (function next() {\n            if (pageNum < x.pages.length) {\n              var page = doOne(x.pages[pageNum]);\n              group.append(page);\n              options.progress({\n                page: page,\n                pageNum: ++pageNum,\n                totalPages: x.pages.length,\n                cancel: function () {\n                  canceled = true;\n                }\n              });\n              if (!canceled) {\n                setTimeout(next);\n              } else {\n                // XXX: should we also fail() the deferred object?\n                x.container.parentNode.removeChild(x.container);\n              }\n            } else {\n              x.container.parentNode.removeChild(x.container);\n              promise.resolve(group);\n            }\n          })();\n        } else {\n          x.pages.forEach(function (page) {\n            group.append(doOne(page));\n          });\n          x.container.parentNode.removeChild(x.container);\n          promise.resolve(group);\n        }\n      }, element, forceBreak, pageWidth ? pageWidth - margin.left - margin.right : null, pageHeight ? pageHeight - margin.top - margin.bottom : null, margin, options);\n    } else {\n      promise.resolve(doOne(element));\n    }\n  });\n  function makeTemplate(template) {\n    if (template != null) {\n      if (typeof template == \"string\") {\n        template = compileTemplate(template.replace(/^\\s+|\\s+$/g, \"\"));\n      }\n      if (typeof template == \"function\") {\n        return function (data) {\n          var el = template(data);\n          if (el && typeof el == \"string\") {\n            var div = document.createElement(\"div\");\n            div.innerHTML = el;\n            el = div.firstElementChild;\n          }\n          return el;\n        };\n      }\n      // assumed DOM element\n      return function () {\n        return template.cloneNode(true);\n      };\n    }\n  }\n  function handlePageBreaks(callback, element, forceBreak, pageWidth, pageHeight, margin, options) {\n    var template = makeTemplate(options.template);\n    var doc = element.ownerDocument;\n    var pages = [];\n    var copy = options._destructive ? element : cloneNodes(element);\n    var container = doc.createElement(\"KENDO-PDF-DOCUMENT\");\n    var adjust = 0;\n\n    // make sure <tfoot> elements are at the end (Grid widget\n    // places TFOOT before TBODY, tricking our algorithm to\n    // insert a page break right after the header).\n    // https://github.com/telerik/kendo/issues/4699\n    slice(copy.querySelectorAll(\"tfoot\")).forEach(function (tfoot) {\n      tfoot.parentNode.appendChild(tfoot);\n    });\n\n    // remember the index of each LI from an ordered list.\n    // we'll use it to reconstruct the proper numbering.\n    slice(copy.querySelectorAll(\"ol\")).forEach(function (ol) {\n      slice(ol.children).forEach(function (li, index) {\n        li.setAttribute(\"kendo-split-index\", index);\n      });\n    });\n    setCSS(container, {\n      display: \"block\",\n      position: \"absolute\",\n      boxSizing: \"content-box\",\n      left: \"-10000px\",\n      top: \"-10000px\"\n    });\n    if (pageWidth) {\n      // subtle: if we don't set the width *and* margins here, the layout in this\n      // container will be different from the one in our final page elements, and we'll\n      // split at the wrong places.\n      setCSS(container, {\n        width: pageWidth + \"px\",\n        paddingLeft: margin.left + \"px\",\n        paddingRight: margin.right + \"px\"\n      });\n\n      // when the first element has a margin-top (i.e. a <h1>) the page will be\n      // inadvertently enlarged by that number (the browser will report the container's\n      // bounding box top to start at the element's top, rather than including its\n      // margin).  Adding overflow: hidden seems to fix it.\n      //\n      // to understand the difference, try the following snippets in your browser:\n      //\n      // 1. <div style=\"background: yellow\">\n      //      <h1 style=\"margin: 3em\">Foo</h1>\n      //    </div>\n      //\n      // 2. <div style=\"background: yellow; overflow: hidden\">\n      //      <h1 style=\"margin: 3em\">Foo</h1>\n      //    </div>\n      //\n      // this detail is not important when automatic page breaking is not requested, hence\n      // doing it only if pageWidth is defined.\n      setCSS(copy, {\n        overflow: \"hidden\"\n      });\n    }\n    element.parentNode.insertBefore(container, element);\n    container.appendChild(copy);\n\n    // With cache disabled, images will still have height zero until their `complete` attribute\n    // is true.  `whenImagesAreActuallyLoaded` will wait for it.\n    if (options.beforePageBreak) {\n      whenImagesAreActuallyLoaded([container], function () {\n        options.beforePageBreak(container, doPageBreak);\n      });\n    } else {\n      whenImagesAreActuallyLoaded([container], doPageBreak);\n    }\n    function doPageBreak() {\n      if (forceBreak != \"-\" || pageHeight) {\n        splitElement(copy);\n      }\n      {\n        var page = makePage();\n        copy.parentNode.insertBefore(page, copy);\n        page.appendChild(copy);\n      }\n      if (template) {\n        pages.forEach(function (page, i) {\n          var el = template({\n            element: page,\n            pageNum: i + 1,\n            totalPages: pages.length\n          });\n          if (el) {\n            page.appendChild(el);\n          }\n        });\n      }\n      cacheImages(pages, callback.bind(null, {\n        pages: pages,\n        container: container\n      }));\n    }\n    function keepTogether(el) {\n      if (options.keepTogether && matches(el, options.keepTogether) && el.offsetHeight <= pageHeight - adjust) {\n        return true;\n      }\n      var tag = el.tagName;\n      if (/^h[1-6]$/i.test(tag) && el.offsetHeight >= pageHeight - adjust) {\n        return false;\n      }\n      return el.getAttribute(\"data-kendo-chart\") || /^(?:img|tr|thead|th|tfoot|iframe|svg|object|canvas|input|textarea|select|video|h[1-6])/i.test(el.tagName);\n    }\n    function splitElement(element) {\n      if (element.tagName == \"TABLE\") {\n        setCSS(element, {\n          tableLayout: \"fixed\"\n        });\n      }\n      if (keepTogether(element)) {\n        return;\n      }\n      var style = getComputedStyle(element);\n      var bottomPadding = parseFloat(getPropertyValue(style, \"padding-bottom\"));\n      var bottomBorder = parseFloat(getPropertyValue(style, \"border-bottom-width\"));\n      var saveAdjust = adjust;\n      adjust += bottomPadding + bottomBorder;\n      var isFirst = true;\n      for (var el = element.firstChild; el; el = el.nextSibling) {\n        if (el.nodeType == 1 /* Element */) {\n          isFirst = false;\n          if (matches(el, forceBreak)) {\n            breakAtElement(el);\n            continue;\n          }\n          if (!pageHeight) {\n            // we're in \"manual breaks mode\"\n            splitElement(el);\n            continue;\n          }\n          if (!/^(?:static|relative)$/.test(getPropertyValue(getComputedStyle(el), \"position\"))) {\n            continue;\n          }\n          var fall = fallsOnMargin(el);\n          if (fall == 1) {\n            // element starts on next page, break before anyway.\n            breakAtElement(el);\n          } else if (fall) {\n            // elements ends up on next page, or possibly doesn't fit on a page at\n            // all.  break before it anyway if it's an <img> or <tr>, otherwise\n            // attempt to split.\n            if (keepTogether(el)) {\n              breakAtElement(el);\n            } else {\n              splitElement(el);\n            }\n          } else {\n            splitElement(el);\n          }\n        } else if (el.nodeType == 3 /* Text */ && pageHeight) {\n          splitText(el, isFirst);\n          isFirst = false;\n        }\n      }\n      adjust = saveAdjust;\n    }\n    function firstInParent(el) {\n      var p = el.parentNode,\n        first = p.firstChild;\n      if (el === first) {\n        return true;\n      }\n      if (el === p.children[0]) {\n        if (first.nodeType == 7 /* comment */ || first.nodeType == 8 /* processing instruction */) {\n          return true;\n        }\n        if (first.nodeType == 3 /* text */) {\n          // if whitespace only we can probably consider it's first\n          return !/\\S/.test(first.data);\n        }\n      }\n      return false;\n    }\n    function breakAtElement(el) {\n      if (el.nodeType == 1 && el !== copy && firstInParent(el)) {\n        return breakAtElement(el.parentNode);\n      }\n      var table, colgroup, thead, grid, gridHead;\n      table = closest(el, \"table\");\n      colgroup = table && table.querySelector(\"colgroup\");\n      if (options.repeatHeaders) {\n        thead = table && table.querySelector(\"thead\");\n\n        // If we break page in a Kendo Grid, repeat its header.  This ugly hack is\n        // necessary because a scrollable grid will keep the header in a separate\n        // <table> element from its content.\n        //\n        // XXX: This is likely to break as soon as the widget HTML is modified.\n        grid = closest(el, \".k-grid.k-widget\");\n        if (grid && grid.querySelector(\".k-auto-scrollable\")) {\n          gridHead = grid.querySelector(\".k-grid-header\");\n        }\n      }\n      var page = makePage();\n      var range = doc.createRange();\n      range.setStartBefore(copy);\n      range.setEndBefore(el);\n      page.appendChild(range.extractContents());\n      copy.parentNode.insertBefore(page, copy);\n      preventBulletOnListItem(el.parentNode);\n      if (table) {\n        table = closest(el, \"table\"); // that's the <table> on next page!\n        if (options.repeatHeaders && thead) {\n          table.insertBefore(thead.cloneNode(true), table.firstChild);\n        }\n        if (colgroup) {\n          table.insertBefore(colgroup.cloneNode(true), table.firstChild);\n        }\n      }\n      if (options.repeatHeaders && gridHead) {\n        grid = closest(el, \".k-grid.k-widget\");\n        grid.insertBefore(gridHead.cloneNode(true), grid.firstChild);\n      }\n    }\n    function makePage() {\n      var page = doc.createElement(\"KENDO-PDF-PAGE\");\n      setCSS(page, {\n        display: \"block\",\n        boxSizing: \"content-box\",\n        width: pageWidth ? pageWidth + \"px\" : \"auto\",\n        padding: margin.top + \"px \" + margin.right + \"px \" + margin.bottom + \"px \" + margin.left + \"px\",\n        // allow absolutely positioned elements to be relative to current page\n        position: \"relative\",\n        // without the following we might affect layout of subsequent pages\n        height: pageHeight ? pageHeight + \"px\" : \"auto\",\n        overflow: pageHeight || pageWidth ? \"hidden\" : \"visible\",\n        clear: \"both\"\n      });\n\n      // debug\n      // $(\"<div>\").css({\n      //     position  : \"absolute\",\n      //     left      : margin.left,\n      //     top       : margin.top,\n      //     width     : pageWidth,\n      //     height    : pageHeight,\n      //     boxSizing : \"border-box\",\n      //     background: \"rgba(255, 255, 0, 0.5)\"\n      //     //border    : \"1px solid red\"\n      // }).appendTo(page);\n\n      if (options && options.pageClassName) {\n        page.className = options.pageClassName;\n      }\n      pages.push(page);\n      return page;\n    }\n    function fallsOnMargin(thing) {\n      var box = thing.getBoundingClientRect();\n      if (box.width === 0 || box.height === 0) {\n        // I'd say an element with dimensions zero fits on current page.\n        return 0;\n      }\n      var top = copy.getBoundingClientRect().top;\n      var available = pageHeight - adjust;\n      return box.height > available ? 3 : box.top - top > available ? 1 : box.bottom - top > available ? 2 : 0;\n    }\n    function splitText(node, isFirst) {\n      if (!/\\S/.test(node.data)) {\n        return;\n      }\n      var len = node.data.length;\n      var range = doc.createRange();\n      range.selectNodeContents(node);\n      var fall = fallsOnMargin(range);\n      if (!fall) {\n        return; // the whole text fits on current page\n      }\n\n      var nextnode = node;\n      if (fall == 1) {\n        // starts on next page, break before anyway.\n        if (isFirst) {\n          // avoid leaving an empty <p>, <li>, etc. on previous page.\n          breakAtElement(node.parentNode);\n        } else {\n          breakAtElement(node);\n        }\n      } else {\n        (function findEOP(min, pos, max) {\n          range.setEnd(node, pos);\n          if (min == pos || pos == max) {\n            return pos;\n          }\n          if (fallsOnMargin(range)) {\n            return findEOP(min, min + pos >> 1, pos);\n          } else {\n            return findEOP(pos, pos + max >> 1, max);\n          }\n        })(0, len >> 1, len);\n        if (!/\\S/.test(range.toString()) && isFirst) {\n          // avoid leaving an empty <p>, <li>, etc. on previous page.\n          breakAtElement(node.parentNode);\n        } else {\n          // This is only needed for IE, but it feels cleaner to do it anyway.  Without\n          // it, IE will truncate a very long text (playground/pdf-long-text-2.html).\n          nextnode = node.splitText(range.endOffset);\n          var page = makePage();\n          range.setStartBefore(copy);\n          page.appendChild(range.extractContents());\n          copy.parentNode.insertBefore(page, copy);\n          preventBulletOnListItem(nextnode.parentNode);\n        }\n      }\n      splitText(nextnode);\n    }\n    function preventBulletOnListItem(el) {\n      // set a hint on continued LI elements, to tell the\n      // renderer not to draw the bullet again.\n      // https://github.com/telerik/kendo-ui-core/issues/2732\n      var li = closest(el, \"li\");\n      if (li) {\n        li.setAttribute(\"kendo-no-bullet\", \"1\");\n        preventBulletOnListItem(li.parentNode);\n      }\n    }\n  }\n  return promise;\n}\n\n// This is needed for the Spreadsheet print functionality.  Since\n// there we only need to draw text, this cuts through the ceremony\n// of drawDOM/renderElement and renders the text node directly.\nfunction drawText(element) {\n  var group = new Group();\n  nodeInfo._clipbox = false;\n  nodeInfo._matrix = geo.Matrix.unit();\n  nodeInfo._stackingContext = {\n    element: element,\n    group: group\n  };\n  pushNodeInfo(element, getComputedStyle(element), group);\n  if (element.firstChild.nodeType == 3 /* Text */) {\n    // avoid the penalty of renderElement\n    renderText(element, element.firstChild, group);\n  } else {\n    _renderElement(element, group);\n  }\n  popNodeInfo();\n  return group;\n}\nvar parseBackgroundImage = function () {\n  var tok_linear_gradient = /^((-webkit-|-moz-|-o-|-ms-)?linear-gradient\\s*)\\(/;\n  //var tok_radial_gradient  = /^((-webkit-|-moz-|-o-|-ms-)?radial-gradient\\s*)\\(/;\n  var tok_percent = /^([-0-9.]+%)/;\n  var tok_length = /^([-0-9.]+px)/;\n  var tok_keyword = /^(left|right|top|bottom|to|center)\\W/;\n  var tok_angle = /^([-0-9.]+(deg|grad|rad|turn)|0)/;\n  var tok_whitespace = /^(\\s+)/;\n  var tok_popen = /^(\\()/;\n  var tok_pclose = /^(\\))/;\n  var tok_comma = /^(,)/;\n  var tok_url = /^(url)\\(/;\n  var tok_content = /^(.*?)\\)/;\n  var cache1 = {},\n    cache2 = {};\n  function parse(input) {\n    var orig = input;\n    if (hasOwnProperty(cache1, orig)) {\n      return cache1[orig];\n    }\n    function skip_ws() {\n      var m = tok_whitespace.exec(input);\n      if (m) {\n        input = input.substr(m[1].length);\n      }\n    }\n    function read(token) {\n      skip_ws();\n      var m = token.exec(input);\n      if (m) {\n        input = input.substr(m[1].length);\n        return m[1];\n      }\n    }\n    function read_stop() {\n      var color = utils_parseColor(input, true);\n      var length, percent;\n      if (color) {\n        var match = /^#[0-9a-f]+/i.exec(input) || /^rgba?\\(.*?\\)/i.exec(input) || /^..*?\\b/.exec(input); // maybe named color\n        input = input.substr(match[0].length);\n        color = color.toRGB();\n        if (!(length = read(tok_length))) {\n          percent = read(tok_percent);\n        }\n        return {\n          color: color,\n          length: length,\n          percent: percent\n        };\n      }\n    }\n    function read_linear_gradient(propName) {\n      var angle;\n      var to1, to2;\n      var stops = [];\n      var reverse = false;\n      if (read(tok_popen)) {\n        // 1. [ <angle> || to <side-or-corner>, ]?\n        angle = read(tok_angle);\n        if (angle == \"0\") {\n          angle = \"0deg\"; // Edge\n        }\n\n        if (angle) {\n          angle = parseAngle(angle);\n          read(tok_comma);\n        } else {\n          to1 = read(tok_keyword);\n          if (to1 == \"to\") {\n            to1 = read(tok_keyword);\n          } else if (to1 && /^-/.test(propName)) {\n            reverse = true;\n          }\n          to2 = read(tok_keyword);\n          read(tok_comma);\n        }\n        if (/-moz-/.test(propName) && angle == null && to1 == null) {\n          var x = read(tok_percent),\n            y = read(tok_percent);\n          reverse = true;\n          if (x == \"0%\") {\n            to1 = \"left\";\n          } else if (x == \"100%\") {\n            to1 = \"right\";\n          }\n          if (y == \"0%\") {\n            to2 = \"top\";\n          } else if (y == \"100%\") {\n            to2 = \"bottom\";\n          }\n          read(tok_comma);\n        }\n\n        // 2. color stops\n        while (input && !read(tok_pclose)) {\n          var stop = read_stop();\n          if (!stop) {\n            break;\n          }\n          stops.push(stop);\n          read(tok_comma);\n        }\n        return {\n          type: \"linear\",\n          angle: angle,\n          to: to1 && to2 ? to1 + \" \" + to2 : to1 ? to1 : to2 ? to2 : null,\n          stops: stops,\n          reverse: reverse\n        };\n      }\n    }\n    function read_url() {\n      if (read(tok_popen)) {\n        var url = read(tok_content);\n        url = url.replace(/^['\"]+|[\"']+$/g, \"\");\n        read(tok_pclose);\n        return {\n          type: \"url\",\n          url: url\n        };\n      }\n    }\n    var tok;\n    if (tok = read(tok_linear_gradient)) {\n      tok = read_linear_gradient(tok);\n    } else if (tok = read(tok_url)) {\n      tok = read_url();\n    }\n    return cache1[orig] = tok || {\n      type: \"none\"\n    };\n  }\n  return function (input) {\n    if (hasOwnProperty(cache2, input)) {\n      return cache2[input];\n    }\n    return cache2[input] = splitProperty(input).map(parse);\n  };\n}();\nvar splitProperty = function () {\n  var cache = {};\n  return function (input, separator) {\n    if (!separator) {\n      separator = /^\\s*,\\s*/;\n    }\n    var cacheKey = input + separator;\n    if (hasOwnProperty(cache, cacheKey)) {\n      return cache[cacheKey];\n    }\n    var ret = [];\n    var last = 0,\n      pos = 0;\n    var in_paren = 0;\n    var in_string = false;\n    var m;\n    function looking_at(rx) {\n      return m = rx.exec(input.substr(pos));\n    }\n    function trim(str) {\n      return str.replace(/^\\s+|\\s+$/g, \"\");\n    }\n    while (pos < input.length) {\n      if (!in_string && looking_at(/^[\\(\\[\\{]/)) {\n        in_paren++;\n        pos++;\n      } else if (!in_string && looking_at(/^[\\)\\]\\}]/)) {\n        in_paren--;\n        pos++;\n      } else if (!in_string && looking_at(/^[\\\"\\']/)) {\n        in_string = m[0];\n        pos++;\n      } else if (in_string == \"'\" && looking_at(/^\\\\\\'/)) {\n        pos += 2;\n      } else if (in_string == '\"' && looking_at(/^\\\\\\\"/)) {\n        pos += 2;\n      } else if (in_string == \"'\" && looking_at(/^\\'/)) {\n        in_string = false;\n        pos++;\n      } else if (in_string == '\"' && looking_at(/^\\\"/)) {\n        in_string = false;\n        pos++;\n      } else if (looking_at(separator)) {\n        if (!in_string && !in_paren && pos > last) {\n          ret.push(trim(input.substring(last, pos)));\n          last = pos + m[0].length;\n        }\n        pos += m[0].length;\n      } else {\n        pos++;\n      }\n    }\n    if (last < pos) {\n      ret.push(trim(input.substring(last, pos)));\n    }\n    return cache[cacheKey] = ret;\n  };\n}();\nvar getFontURL = function (cache) {\n  return function (el) {\n    // XXX: for IE we get here the whole cssText of the rule,\n    // because the computedStyle.src is empty.  Next time we need\n    // to fix these regexps we better write a CSS parser. :-\\\n    var url = cache[el];\n    if (!url) {\n      var m;\n      if (m = /url\\((['\"]?)([^'\")]*?)\\1\\)\\s+format\\((['\"]?)truetype\\3\\)/.exec(el)) {\n        url = cache[el] = m[2];\n      } else if (m = /url\\((['\"]?)([^'\")]*?\\.ttf)\\1\\)/.exec(el)) {\n        url = cache[el] = m[2];\n      }\n    }\n    return url;\n  };\n}(Object.create(null));\nvar getFontHeight = function (cache) {\n  return function (font) {\n    var height = cache[font];\n    if (height == null) {\n      height = cache[font] = measureText(\"Mapq\", {\n        font: font\n      }).height;\n    }\n    return height;\n  };\n}(Object.create(null));\nfunction getFontFaces(doc) {\n  if (doc == null) {\n    doc = document;\n  }\n  var result = {};\n  for (var i = 0; i < doc.styleSheets.length; ++i) {\n    doStylesheet(doc.styleSheets[i]);\n  }\n  return result;\n  function doStylesheet(ss) {\n    if (ss) {\n      var rules = null;\n      try {\n        rules = ss.cssRules;\n      } catch (ex) {}\n      if (rules) {\n        addRules(ss, rules);\n      }\n    }\n  }\n  function findFonts(rule) {\n    var src = getPropertyValue(rule.style, \"src\");\n    if (src) {\n      return splitProperty(src).reduce(function (a, el) {\n        var font = getFontURL(el);\n        if (font) {\n          a.push(font);\n        }\n        return a;\n      }, []);\n    } else {\n      // Internet Explorer\n      // XXX: this is gross.  should work though for valid CSS.\n      var font = getFontURL(rule.cssText);\n      return font ? [font] : [];\n    }\n  }\n  function addRules(styleSheet, rules) {\n    for (var i = 0; i < rules.length; ++i) {\n      var r = rules[i];\n      switch (r.type) {\n        case 3:\n          // CSSImportRule\n          doStylesheet(r.styleSheet);\n          break;\n        case 5:\n          // CSSFontFaceRule\n          var style = r.style;\n          var family = splitProperty(getPropertyValue(style, \"font-family\"));\n          var bold = /^([56789]00|bold)$/i.test(getPropertyValue(style, \"font-weight\"));\n          var italic = \"italic\" == getPropertyValue(style, \"font-style\");\n          var src = findFonts(r);\n          if (src.length > 0) {\n            addRule(styleSheet, family, bold, italic, src[0]);\n          }\n      }\n    }\n  }\n  function addRule(styleSheet, names, bold, italic, url) {\n    // We get full resolved absolute URLs in Chrome, but sadly\n    // not in Firefox.\n    if (!/^data:/i.test(url)) {\n      if (!(/^[^\\/:]+:\\/\\//.test(url) || /^\\//.test(url))) {\n        url = String(styleSheet.href).replace(/[^\\/]*$/, \"\") + url;\n      }\n    }\n    names.forEach(function (name) {\n      name = name.replace(/^(['\"]?)(.*?)\\1$/, \"$2\"); // it's quoted\n      if (bold) {\n        name += \"|bold\";\n      }\n      if (italic) {\n        name += \"|italic\";\n      }\n      result[name] = url;\n    });\n  }\n}\nfunction hasOwnProperty(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction getCounter(name) {\n  name = \"_counter_\" + name;\n  return nodeInfo[name];\n}\nfunction getAllCounters(name) {\n  var values = [],\n    p = nodeInfo;\n  name = \"_counter_\" + name;\n  while (p) {\n    if (hasOwnProperty(p, name)) {\n      values.push(p[name]);\n    }\n    p = Object.getPrototypeOf(p);\n  }\n  return values.reverse();\n}\nfunction incCounter(name, inc) {\n  var p = nodeInfo;\n  name = \"_counter_\" + name;\n  while (p && !hasOwnProperty(p, name)) {\n    p = Object.getPrototypeOf(p);\n  }\n  if (!p) {\n    p = nodeInfo._root;\n  }\n  p[name] = (p[name] || 0) + (inc == null ? 1 : inc);\n}\nfunction resetCounter(name, val) {\n  name = \"_counter_\" + name;\n  nodeInfo[name] = val == null ? 0 : val;\n}\nfunction doCounters(a, f, def) {\n  for (var i = 0; i < a.length;) {\n    var name = a[i++];\n    var val = parseFloat(a[i]);\n    if (isNaN(val)) {\n      f(name, def);\n    } else {\n      f(name, val);\n      ++i;\n    }\n  }\n}\nfunction updateCounters(style) {\n  var counterReset = getPropertyValue(style, \"counter-reset\");\n  if (counterReset) {\n    doCounters(splitProperty(counterReset, /^\\s+/), resetCounter, 0);\n  }\n  var counterIncrement = getPropertyValue(style, \"counter-increment\");\n  if (counterIncrement) {\n    doCounters(splitProperty(counterIncrement, /^\\s+/), incCounter, 1);\n  }\n}\nfunction parseColor(str, css) {\n  var color = utils_parseColor(str, true);\n  if (color) {\n    color = color.toRGB();\n    if (css) {\n      color = color.toCssRgba();\n    } else if (color.a === 0) {\n      color = null;\n    }\n  }\n  return color;\n}\nfunction whenImagesAreActuallyLoaded(elements, callback) {\n  var pending = 0;\n  var done = false;\n  elements.forEach(function (el) {\n    var images = el.querySelectorAll(\"img\");\n    for (var i = 0; i < images.length; ++i) {\n      var img = images[i];\n      if (!img.complete) {\n        pending++;\n        img.onload = img.onerror = next;\n      }\n    }\n  });\n  if (!pending) {\n    next();\n  }\n  function next() {\n    if (!done && --pending <= 0) {\n      callback();\n      done = true;\n    }\n  }\n}\nfunction cacheImages(elements, callback) {\n  var urls = [];\n  function add(url) {\n    if (!IMAGE_CACHE[url]) {\n      IMAGE_CACHE[url] = true;\n      urls.push(url);\n    }\n  }\n  elements.forEach(function dive(element) {\n    if (/^img$/i.test(element.tagName)) {\n      add(element.src);\n    }\n    parseBackgroundImage(getPropertyValue(getComputedStyle(element), \"background-image\")).forEach(function (bg) {\n      if (bg.type == \"url\") {\n        add(bg.url);\n      }\n    });\n    if (element.children) {\n      slice(element.children).forEach(dive);\n    }\n  });\n  var count = urls.length;\n  function next() {\n    if (--count <= 0) {\n      // Even though we cached them, they simply won't be available immediately in the newly\n      // created DOM.  Previously we'd allow a 10ms timeout, but that's arbitrary and clearly\n      // not working in all cases (https://github.com/telerik/kendo/issues/5399), so this\n      // function will wait for their .complete attribute.\n      whenImagesAreActuallyLoaded(elements, callback);\n    }\n  }\n  if (count === 0) {\n    next();\n  }\n  urls.forEach(function (url) {\n    var img = IMAGE_CACHE[url] = new window.Image();\n    if (!/^data:/i.test(url)) {\n      img.crossOrigin = \"Anonymous\";\n    }\n    img.src = url;\n    if (img.complete) {\n      next();\n    } else {\n      img.onload = next;\n      img.onerror = function () {\n        IMAGE_CACHE[url] = null;\n        next();\n      };\n    }\n  });\n}\nfunction alphaNumeral(n) {\n  var result = \"\";\n  do {\n    var r = n % 26;\n    result = String.fromCharCode(97 + r) + result;\n    n = Math.floor(n / 26);\n  } while (n > 0);\n  return result;\n}\nfunction pushNodeInfo(element, style, group) {\n  nodeInfo = Object.create(nodeInfo);\n  nodeInfo[element.tagName.toLowerCase()] = {\n    element: element,\n    style: style\n  };\n  var decoration = getPropertyValue(style, \"text-decoration\");\n  if (decoration && decoration != \"none\") {\n    var color = getPropertyValue(style, \"text-decoration-color\");\n    decoration.split(/\\s+/g).forEach(function (name) {\n      if (!nodeInfo[name]) {\n        nodeInfo[name] = color;\n        if (name == \"underline\") {\n          var offset = getPropertyValue(style, \"text-underline-offset\");\n          if (offset != \"auto\") {\n            nodeInfo[\"underline-offset\"] = parseFloat(offset);\n          }\n        }\n      }\n    });\n  }\n  if (createsStackingContext(style)) {\n    nodeInfo._stackingContext = {\n      element: element,\n      group: group\n    };\n  }\n}\nfunction popNodeInfo() {\n  nodeInfo = Object.getPrototypeOf(nodeInfo);\n}\nfunction updateClipbox(path) {\n  if (nodeInfo._clipbox != null) {\n    var box = path.bbox(nodeInfo._matrix);\n    if (nodeInfo._clipbox) {\n      nodeInfo._clipbox = geo.Rect.intersect(nodeInfo._clipbox, box);\n    } else {\n      nodeInfo._clipbox = box;\n    }\n  }\n}\nfunction emptyClipbox() {\n  var cb = nodeInfo._clipbox;\n  if (cb == null) {\n    return true;\n  }\n  if (cb) {\n    return cb.width() === 0 || cb.height() === 0;\n  }\n}\nfunction createsStackingContext(style) {\n  function prop(name) {\n    return getPropertyValue(style, name);\n  }\n  if (prop(\"transform\") != \"none\" || prop(\"position\") != \"static\" || prop(\"z-index\") != \"auto\" || prop(\"opacity\") < 1) {\n    return true;\n  }\n}\nfunction getComputedStyle(element, pseudoElt) {\n  return window.getComputedStyle(element, pseudoElt || null);\n}\nfunction getPropertyValue(style, prop, defa) {\n  var val = style.getPropertyValue(prop);\n  if (val == null || val === \"\") {\n    if (browser.webkit) {\n      val = style.getPropertyValue(\"-webkit-\" + prop);\n    } else if (browser.mozilla) {\n      val = style.getPropertyValue(\"-moz-\" + prop);\n    } else if (browser.opera) {\n      val = style.getPropertyValue(\"-o-\" + prop);\n    } else if (microsoft) {\n      val = style.getPropertyValue(\"-ms-\" + prop);\n    }\n  }\n  if (arguments.length > 2 && (val == null || val === \"\")) {\n    return defa;\n  } else {\n    return val;\n  }\n}\nfunction pleaseSetPropertyValue(style, prop, value, important) {\n  style.setProperty(prop, value, important);\n  if (browser.webkit) {\n    style.setProperty(\"-webkit-\" + prop, value, important);\n  } else if (browser.mozilla) {\n    style.setProperty(\"-moz-\" + prop, value, important);\n  } else if (browser.opera) {\n    style.setProperty(\"-o-\" + prop, value, important);\n  } else if (microsoft) {\n    style.setProperty(\"-ms-\" + prop, value, important);\n    prop = \"ms\" + prop.replace(/(^|-)([a-z])/g, function (s, p1, p2) {\n      return p1 + p2.toUpperCase();\n    });\n    style[prop] = value;\n  }\n}\nfunction getBorder(style, side) {\n  side = \"border-\" + side;\n  return {\n    width: parseFloat(getPropertyValue(style, side + \"-width\")),\n    style: getPropertyValue(style, side + \"-style\"),\n    color: parseColor(getPropertyValue(style, side + \"-color\"), true)\n  };\n}\nfunction saveStyle(element, func) {\n  var prev = element.style.cssText;\n  var result = func();\n  element.style.cssText = prev;\n  return result;\n}\nfunction getBorderRadius(style, side) {\n  var r = getPropertyValue(style, \"border-\" + side + \"-radius\").split(/\\s+/g).map(parseFloat);\n  if (r.length == 1) {\n    r.push(r[0]);\n  }\n  return sanitizeRadius({\n    x: r[0],\n    y: r[1]\n  });\n}\nfunction getContentBox(element) {\n  var box = element.getBoundingClientRect();\n  box = innerBox(box, \"border-*-width\", element);\n  box = innerBox(box, \"padding-*\", element);\n  return box;\n}\nfunction innerBox(box, prop, element) {\n  var style, wt, wr, wb, wl;\n  if (typeof prop == \"string\") {\n    style = getComputedStyle(element);\n    wt = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"top\")));\n    wr = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"right\")));\n    wb = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"bottom\")));\n    wl = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"left\")));\n  } else if (typeof prop == \"number\") {\n    wt = wr = wb = wl = prop;\n  }\n  return {\n    top: box.top + wt,\n    right: box.right - wr,\n    bottom: box.bottom - wb,\n    left: box.left + wl,\n    width: box.right - box.left - wr - wl,\n    height: box.bottom - box.top - wb - wt\n  };\n}\nfunction getTransform(style) {\n  var transform = getPropertyValue(style, \"transform\");\n  if (transform == \"none\") {\n    return null;\n  }\n  var matrix = /^\\s*matrix\\(\\s*(.*?)\\s*\\)\\s*$/.exec(transform);\n  if (matrix) {\n    var origin = getPropertyValue(style, \"transform-origin\");\n    matrix = matrix[1].split(/\\s*,\\s*/g).map(parseFloat);\n    origin = origin.split(/\\s+/g).map(parseFloat);\n    return {\n      matrix: matrix,\n      origin: origin\n    };\n  }\n}\nfunction radiansToDegrees(radians) {\n  return 180 * radians / Math.PI % 360;\n}\nfunction parseAngle(angle) {\n  var num = parseFloat(angle);\n  if (/grad$/.test(angle)) {\n    return Math.PI * num / 200;\n  } else if (/rad$/.test(angle)) {\n    return num;\n  } else if (/turn$/.test(angle)) {\n    return Math.PI * num * 2;\n  } else if (/deg$/.test(angle)) {\n    return Math.PI * num / 180;\n  }\n}\nfunction setTransform(shape, m) {\n  m = new geo.Matrix(m[0], m[1], m[2], m[3], m[4], m[5]);\n  shape.transform(m);\n  return m;\n}\nfunction setClipping(shape, clipPath) {\n  shape.clip(clipPath);\n}\nfunction addArcToPath(path, x, y, options) {\n  var points = new geo.Arc([x, y], options).curvePoints(),\n    i = 1;\n  while (i < points.length) {\n    path.curveTo(points[i++], points[i++], points[i++]);\n  }\n}\nfunction sanitizeRadius(r) {\n  if (r.x <= 0 || r.y <= 0) {\n    r.x = r.y = 0;\n  }\n  return r;\n}\nfunction adjustBorderRadiusForBox(box, rTL, rTR, rBR, rBL) {\n  // adjust border radiuses such that the sum of adjacent\n  // radiuses is not bigger than the length of the side.\n  // seems the correct algorithm is variant (3) from here:\n  // http://www.w3.org/Style/CSS/Tracker/issues/29?changelog\n  var tl_x = Math.max(0, rTL.x),\n    tl_y = Math.max(0, rTL.y);\n  var tr_x = Math.max(0, rTR.x),\n    tr_y = Math.max(0, rTR.y);\n  var br_x = Math.max(0, rBR.x),\n    br_y = Math.max(0, rBR.y);\n  var bl_x = Math.max(0, rBL.x),\n    bl_y = Math.max(0, rBL.y);\n  var f = Math.min(box.width / (tl_x + tr_x), box.height / (tr_y + br_y), box.width / (br_x + bl_x), box.height / (bl_y + tl_y));\n  if (f < 1) {\n    tl_x *= f;\n    tl_y *= f;\n    tr_x *= f;\n    tr_y *= f;\n    br_x *= f;\n    br_y *= f;\n    bl_x *= f;\n    bl_y *= f;\n  }\n  return {\n    tl: {\n      x: tl_x,\n      y: tl_y\n    },\n    tr: {\n      x: tr_x,\n      y: tr_y\n    },\n    br: {\n      x: br_x,\n      y: br_y\n    },\n    bl: {\n      x: bl_x,\n      y: bl_y\n    }\n  };\n}\nfunction elementRoundBox(element, box, type) {\n  var style = getComputedStyle(element);\n  var rTL = getBorderRadius(style, \"top-left\");\n  var rTR = getBorderRadius(style, \"top-right\");\n  var rBL = getBorderRadius(style, \"bottom-left\");\n  var rBR = getBorderRadius(style, \"bottom-right\");\n  if (type == \"padding\" || type == \"content\") {\n    var bt = getBorder(style, \"top\");\n    var br = getBorder(style, \"right\");\n    var bb = getBorder(style, \"bottom\");\n    var bl = getBorder(style, \"left\");\n    rTL.x -= bl.width;\n    rTL.y -= bt.width;\n    rTR.x -= br.width;\n    rTR.y -= bt.width;\n    rBR.x -= br.width;\n    rBR.y -= bb.width;\n    rBL.x -= bl.width;\n    rBL.y -= bb.width;\n    if (type == \"content\") {\n      var pt = parseFloat(getPropertyValue(style, \"padding-top\"));\n      var pr = parseFloat(getPropertyValue(style, \"padding-right\"));\n      var pb = parseFloat(getPropertyValue(style, \"padding-bottom\"));\n      var pl = parseFloat(getPropertyValue(style, \"padding-left\"));\n      rTL.x -= pl;\n      rTL.y -= pt;\n      rTR.x -= pr;\n      rTR.y -= pt;\n      rBR.x -= pr;\n      rBR.y -= pb;\n      rBL.x -= pl;\n      rBL.y -= pb;\n    }\n  }\n  if (typeof type == \"number\") {\n    rTL.x -= type;\n    rTL.y -= type;\n    rTR.x -= type;\n    rTR.y -= type;\n    rBR.x -= type;\n    rBR.y -= type;\n    rBL.x -= type;\n    rBL.y -= type;\n  }\n  return roundBox(box, rTL, rTR, rBR, rBL);\n}\n\n// Create a drawing.Path for a rounded rectangle.  Receives the\n// bounding box and the border-radiuses in CSS order (top-left,\n// top-right, bottom-right, bottom-left).  The radiuses must be\n// objects containing x (horiz. radius) and y (vertical radius).\nfunction roundBox(box, rTL0, rTR0, rBR0, rBL0) {\n  var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);\n  var rTL = tmp.tl;\n  var rTR = tmp.tr;\n  var rBR = tmp.br;\n  var rBL = tmp.bl;\n  var path = new Path({\n    fill: null,\n    stroke: null\n  });\n  path.moveTo(box.left, box.top + rTL.y);\n  if (rTL.x) {\n    addArcToPath(path, box.left + rTL.x, box.top + rTL.y, {\n      startAngle: -180,\n      endAngle: -90,\n      radiusX: rTL.x,\n      radiusY: rTL.y\n    });\n  }\n  path.lineTo(box.right - rTR.x, box.top);\n  if (rTR.x) {\n    addArcToPath(path, box.right - rTR.x, box.top + rTR.y, {\n      startAngle: -90,\n      endAngle: 0,\n      radiusX: rTR.x,\n      radiusY: rTR.y\n    });\n  }\n  path.lineTo(box.right, box.bottom - rBR.y);\n  if (rBR.x) {\n    addArcToPath(path, box.right - rBR.x, box.bottom - rBR.y, {\n      startAngle: 0,\n      endAngle: 90,\n      radiusX: rBR.x,\n      radiusY: rBR.y\n    });\n  }\n  path.lineTo(box.left + rBL.x, box.bottom);\n  if (rBL.x) {\n    addArcToPath(path, box.left + rBL.x, box.bottom - rBL.y, {\n      startAngle: 90,\n      endAngle: 180,\n      radiusX: rBL.x,\n      radiusY: rBL.y\n    });\n  }\n  return path.close();\n}\nfunction formatCounter(val, style) {\n  var str = String(parseFloat(val));\n  switch (style) {\n    case \"decimal-leading-zero\":\n      if (str.length < 2) {\n        str = \"0\" + str;\n      }\n      return str;\n    case \"lower-roman\":\n      return arabicToRoman(val).toLowerCase();\n    case \"upper-roman\":\n      return arabicToRoman(val).toUpperCase();\n    case \"lower-latin\":\n    case \"lower-alpha\":\n      return alphaNumeral(val - 1);\n    case \"upper-latin\":\n    case \"upper-alpha\":\n      return alphaNumeral(val - 1).toUpperCase();\n    default:\n      return str;\n  }\n}\nfunction evalPseudoElementContent(element, content) {\n  function displayCounter(name, style, separator) {\n    if (!separator) {\n      return formatCounter(getCounter(name) || 0, style);\n    }\n    separator = separator.replace(/^\\s*([\"'])(.*)\\1\\s*$/, \"$2\");\n    return getAllCounters(name).map(function (val) {\n      return formatCounter(val, style);\n    }).join(separator);\n  }\n  var a = splitProperty(content, /^\\s+/);\n  var result = [],\n    m;\n  a.forEach(function (el) {\n    var tmp;\n    if (m = /^\\s*([\"'])(.*)\\1\\s*$/.exec(el)) {\n      result.push(m[2].replace(/\\\\([0-9a-f]{4})/gi, function (s, p) {\n        return String.fromCharCode(parseInt(p, 16));\n      }));\n    } else if (m = /^\\s*counter\\((.*?)\\)\\s*$/.exec(el)) {\n      tmp = splitProperty(m[1]);\n      result.push(displayCounter(tmp[0], tmp[1]));\n    } else if (m = /^\\s*counters\\((.*?)\\)\\s*$/.exec(el)) {\n      tmp = splitProperty(m[1]);\n      result.push(displayCounter(tmp[0], tmp[2], tmp[1]));\n    } else if (m = /^\\s*attr\\((.*?)\\)\\s*$/.exec(el)) {\n      result.push(element.getAttribute(m[1]) || \"\");\n    } else {\n      result.push(el);\n    }\n  });\n  return result.join(\"\");\n}\nfunction getCssText(style) {\n  if (style.cssText) {\n    return style.cssText;\n  }\n  // Status: NEW.  Report year: 2002.  Current year: 2014.\n  // Nice played, Mozillians.\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=137687\n  var result = [];\n  for (var i = 0; i < style.length; ++i) {\n    result.push(style[i] + \": \" + getPropertyValue(style, style[i]));\n  }\n  return result.join(\";\\n\");\n}\nfunction _renderWithPseudoElements(element, group) {\n  if (element.tagName == KENDO_PSEUDO_ELEMENT) {\n    _renderElement(element, group);\n    return;\n  }\n  var fake = [];\n  function pseudo(kind, place) {\n    var style = getComputedStyle(element, kind),\n      content = style.content;\n    updateCounters(style);\n    if (content && content != \"normal\" && content != \"none\" && style.width != \"0px\") {\n      var psel = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);\n      psel.style.cssText = getCssText(style);\n      psel.textContent = evalPseudoElementContent(element, content);\n      element.insertBefore(psel, place);\n      fake.push(psel);\n    }\n  }\n  pseudo(\":before\", element.firstChild);\n  pseudo(\":after\", null);\n  if (fake.length > 0) {\n    var saveClass = element.className;\n    element.className += \" kendo-pdf-hide-pseudo-elements\";\n    _renderElement(element, group);\n    element.className = saveClass;\n    fake.forEach(function (el) {\n      element.removeChild(el);\n    });\n  } else {\n    _renderElement(element, group);\n  }\n}\nfunction _renderElement(element, group) {\n  var style = getComputedStyle(element);\n  var top = getBorder(style, \"top\");\n  var right = getBorder(style, \"right\");\n  var bottom = getBorder(style, \"bottom\");\n  var left = getBorder(style, \"left\");\n  var rTL0 = getBorderRadius(style, \"top-left\");\n  var rTR0 = getBorderRadius(style, \"top-right\");\n  var rBL0 = getBorderRadius(style, \"bottom-left\");\n  var rBR0 = getBorderRadius(style, \"bottom-right\");\n  var dir = getPropertyValue(style, \"direction\");\n  var backgroundColor = getPropertyValue(style, \"background-color\");\n  backgroundColor = parseColor(backgroundColor);\n  var backgroundImage = parseBackgroundImage(getPropertyValue(style, \"background-image\"));\n  var backgroundRepeat = splitProperty(getPropertyValue(style, \"background-repeat\"));\n  var backgroundPosition = splitProperty(getPropertyValue(style, \"background-position\"));\n  var backgroundOrigin = splitProperty(getPropertyValue(style, \"background-origin\"));\n  var backgroundSize = splitProperty(getPropertyValue(style, \"background-size\"));\n\n  // IE shrinks the text with text-overflow: ellipsis,\n  // apparently because the returned bounding box for the range\n  // is limited to the visible area minus space for the dots,\n  // instead of being the full width of the text.\n  //\n  // https://github.com/telerik/kendo/issues/5232\n  // https://github.com/telerik/kendo-ui-core/issues/1868\n  //\n  // We have to test it here rather than in renderText because\n  // text-overflow: ellipsis could be set on a parent element (not\n  // necessarily the one containing the text); in this case,\n  // getComputedStyle(elementWithTheText) will return \"clip\", not\n  // \"ellipsis\" (which is probably a bug, but oh well...)\n  var textOverflow, saveTextOverflow;\n  if (microsoft) {\n    textOverflow = style.textOverflow; // computed style\n    if (textOverflow == \"ellipsis\") {\n      saveTextOverflow = element.style.textOverflow; // own style.\n      element.style.textOverflow = \"clip\";\n    }\n  }\n  if (browser.msie && browser.version < 10) {\n    // IE9 hacks.  getPropertyValue won't return the correct\n    // value.  Sucks that we have to do it here, I'd prefer to\n    // move it in getPropertyValue, but we don't have the\n    // element.\n    backgroundPosition = splitProperty(element.currentStyle.backgroundPosition);\n  }\n  var innerbox = innerBox(element.getBoundingClientRect(), \"border-*-width\", element);\n\n  // CSS \"clip\" property - if present, replace the group with a\n  // new one which is clipped.  This must happen before drawing\n  // the borders and background.\n  (function () {\n    var clip = getPropertyValue(style, \"clip\");\n    var m = /^\\s*rect\\((.*)\\)\\s*$/.exec(clip);\n    if (m) {\n      var a = m[1].split(/[ ,]+/g);\n      var top = a[0] == \"auto\" ? innerbox.top : parseFloat(a[0]) + innerbox.top;\n      var right = a[1] == \"auto\" ? innerbox.right : parseFloat(a[1]) + innerbox.left;\n      var bottom = a[2] == \"auto\" ? innerbox.bottom : parseFloat(a[2]) + innerbox.top;\n      var left = a[3] == \"auto\" ? innerbox.left : parseFloat(a[3]) + innerbox.left;\n      var tmp = new Group();\n      var clipPath = new Path().moveTo(left, top).lineTo(right, top).lineTo(right, bottom).lineTo(left, bottom).close();\n      setClipping(tmp, clipPath);\n      group.append(tmp);\n      group = tmp;\n      updateClipbox(clipPath);\n    }\n  })();\n  var boxes, i, cells;\n  var display = getPropertyValue(style, \"display\");\n  if (display == \"table-row\") {\n    // because of rowspan/colspan, we shouldn't draw background of table row elements on the\n    // box given by its getBoundingClientRect, because if we do we risk overwritting a\n    // previously rendered cell.  https://github.com/telerik/kendo/issues/4881\n    boxes = [];\n    for (i = 0, cells = element.children; i < cells.length; ++i) {\n      boxes.push(cells[i].getBoundingClientRect());\n    }\n  } else {\n    boxes = element.getClientRects();\n    if (boxes.length == 1) {\n      // Workaround the missing borders in Chrome!  getClientRects() boxes contains values\n      // rounded to integer.  getBoundingClientRect() appears to work fine.  We still need\n      // getClientRects() to support cases where there are more boxes (continued inline\n      // elements that might have border/background).\n      boxes = [element.getBoundingClientRect()];\n    }\n  }\n\n  // This function workarounds another Chrome bug, where boxes returned for a table with\n  // border-collapse: collapse will overlap the table border.  Our rendering is not perfect in\n  // such case anyway, but with this is better than without it.\n  boxes = adjustBoxes(boxes);\n  for (i = 0; i < boxes.length; ++i) {\n    drawOneBox(boxes[i], i === 0, i == boxes.length - 1);\n  }\n\n  // Render links as separate groups.  We can't use boxes returned by element's getClientRects\n  // because if display type is \"inline\" (default for <a>), boxes will not include the height of\n  // images inside.  https://github.com/telerik/kendo-ui-core/issues/3359\n  if (element.tagName == \"A\" && element.href && !/^#?$/.test(element.getAttribute(\"href\"))) {\n    if (!nodeInfo._avoidLinks || !matches(element, nodeInfo._avoidLinks)) {\n      var r = document.createRange();\n      r.selectNodeContents(element);\n      slice(r.getClientRects()).forEach(function (box) {\n        var g = new Group();\n        g._pdfLink = {\n          url: element.href,\n          top: box.top,\n          right: box.right,\n          bottom: box.bottom,\n          left: box.left\n        };\n        group.append(g);\n      });\n    }\n  }\n  if (boxes.length > 0 && display == \"list-item\" && !element.getAttribute(\"kendo-no-bullet\")) {\n    drawBullet(boxes[0]);\n  }\n\n  // overflow: hidden/auto - if present, replace the group with\n  // a new one clipped by the inner box.\n  (function () {\n    function clipit() {\n      var clipPath = elementRoundBox(element, innerbox, \"padding\");\n      var tmp = new Group();\n      setClipping(tmp, clipPath);\n      group.append(tmp);\n      group = tmp;\n      updateClipbox(clipPath);\n    }\n    if (isFormField(element)) {\n      clipit();\n    } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow\"))) {\n      clipit();\n    } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow-x\"))) {\n      clipit();\n    } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow-y\"))) {\n      clipit();\n    }\n  })();\n  if (!maybeRenderWidget(element, group)) {\n    renderContents(element, group);\n  }\n  if (microsoft && textOverflow == \"ellipsis\") {\n    element.style.textOverflow = saveTextOverflow;\n  }\n  return group; // only utility functions after this line.\n\n  function adjustBoxes(boxes) {\n    if (/^td$/i.test(element.tagName)) {\n      var table = nodeInfo.table;\n      if (table && getPropertyValue(table.style, \"border-collapse\") == \"collapse\") {\n        var tableBorderLeft = getBorder(table.style, \"left\").width;\n        var tableBorderTop = getBorder(table.style, \"top\").width;\n        // check if we need to adjust\n        if (tableBorderLeft === 0 && tableBorderTop === 0) {\n          return boxes; // nope\n        }\n\n        var tableBox = table.element.getBoundingClientRect();\n        var firstCell = table.element.rows[0].cells[0];\n        var firstCellBox = firstCell.getBoundingClientRect();\n        if (firstCellBox.top == tableBox.top || firstCellBox.left == tableBox.left) {\n          return slice(boxes).map(function (box) {\n            return {\n              left: box.left + tableBorderLeft,\n              top: box.top + tableBorderTop,\n              right: box.right + tableBorderLeft,\n              bottom: box.bottom + tableBorderTop,\n              height: box.height,\n              width: box.width\n            };\n          });\n        }\n      }\n    }\n    return boxes;\n  }\n\n  // this function will be called to draw each border.  it\n  // draws starting at origin and the resulted path must be\n  // translated/rotated to be placed in the proper position.\n  //\n  // arguments are named as if it draws the top border:\n  //\n  //    - `len` the length of the edge\n  //    - `Wtop` the width of the edge (i.e. border-top-width)\n  //    - `Wleft` the width of the left edge (border-left-width)\n  //    - `Wright` the width of the right edge\n  //    - `rl` and `rl` -- the border radius on the left and right\n  //      (objects containing x and y, for horiz/vertical radius)\n  //    - `transform` -- transformation to apply\n  //\n  function drawEdge(color, len, Wtop, Wleft, Wright, rl, rr, transform) {\n    if (Wtop <= 0) {\n      return;\n    }\n    var path,\n      edge = new Group();\n    setTransform(edge, transform);\n    group.append(edge);\n    sanitizeRadius(rl);\n    sanitizeRadius(rr);\n\n    // draw main border.  this is the area without the rounded corners\n    path = new Path({\n      fill: {\n        color: color\n      },\n      stroke: null\n    });\n    edge.append(path);\n    path.moveTo(rl.x ? Math.max(rl.x, Wleft) : 0, 0).lineTo(len - (rr.x ? Math.max(rr.x, Wright) : 0), 0).lineTo(len - Math.max(rr.x, Wright), Wtop).lineTo(Math.max(rl.x, Wleft), Wtop).close();\n    if (rl.x) {\n      drawRoundCorner(Wleft, rl, [-1, 0, 0, 1, rl.x, 0]);\n    }\n    if (rr.x) {\n      drawRoundCorner(Wright, rr, [1, 0, 0, 1, len - rr.x, 0]);\n    }\n\n    // draws one round corner, starting at origin (needs to be\n    // translated/rotated to be placed properly).\n    function drawRoundCorner(Wright, r, transform) {\n      var angle = Math.PI / 2 * Wright / (Wright + Wtop);\n\n      // not sanitizing this one, because negative values\n      // are useful to fill the box correctly.\n      var ri = {\n        x: r.x - Wright,\n        y: r.y - Wtop\n      };\n      var path = new Path({\n        fill: {\n          color: color\n        },\n        stroke: null\n      }).moveTo(0, 0);\n      setTransform(path, transform);\n      addArcToPath(path, 0, r.y, {\n        startAngle: -90,\n        endAngle: -radiansToDegrees(angle),\n        radiusX: r.x,\n        radiusY: r.y\n      });\n      if (ri.x > 0 && ri.y > 0) {\n        path.lineTo(ri.x * Math.cos(angle), r.y - ri.y * Math.sin(angle));\n        addArcToPath(path, 0, r.y, {\n          startAngle: -radiansToDegrees(angle),\n          endAngle: -90,\n          radiusX: ri.x,\n          radiusY: ri.y,\n          anticlockwise: true\n        });\n      } else if (ri.x > 0) {\n        path.lineTo(ri.x, Wtop).lineTo(0, Wtop);\n      } else {\n        path.lineTo(ri.x, Wtop).lineTo(ri.x, 0);\n      }\n      edge.append(path.close());\n    }\n  }\n  function drawBackground(box) {\n    var background = new Group();\n    setClipping(background, roundBox(box, rTL0, rTR0, rBR0, rBL0));\n    group.append(background);\n    if (backgroundColor) {\n      var path = new Path({\n        fill: {\n          color: backgroundColor.toCssRgba()\n        },\n        stroke: null\n      });\n      path.moveTo(box.left, box.top).lineTo(box.right, box.top).lineTo(box.right, box.bottom).lineTo(box.left, box.bottom).close();\n      background.append(path);\n    }\n    for (var i = backgroundImage.length; --i >= 0;) {\n      drawOneBackground(background, box, backgroundImage[i], backgroundRepeat[i % backgroundRepeat.length], backgroundPosition[i % backgroundPosition.length], backgroundOrigin[i % backgroundOrigin.length], backgroundSize[i % backgroundSize.length]);\n    }\n  }\n  function drawOneBackground(group, box, background, backgroundRepeat, backgroundPosition, backgroundOrigin, backgroundSize) {\n    if (!background || background == \"none\") {\n      return;\n    }\n    if (background.type == \"url\") {\n      var img = IMAGE_CACHE[background.url];\n      if (img && img.width > 0 && img.height > 0) {\n        drawBackgroundImage(group, box, img.width, img.height, function (group, rect) {\n          group.append(new Image(background.url, rect));\n        });\n      }\n    } else if (background.type == \"linear\") {\n      drawBackgroundImage(group, box, box.width, box.height, gradientRenderer(background));\n    } else {\n      return;\n    }\n    function drawBackgroundImage(group, box, img_width, img_height, renderBG) {\n      var aspect_ratio = img_width / img_height,\n        f;\n\n      // for background-origin: border-box the box is already appropriate\n      var orgBox = box;\n      if (backgroundOrigin == \"content-box\") {\n        orgBox = innerBox(orgBox, \"border-*-width\", element);\n        orgBox = innerBox(orgBox, \"padding-*\", element);\n      } else if (backgroundOrigin == \"padding-box\") {\n        orgBox = innerBox(orgBox, \"border-*-width\", element);\n      }\n      if (!/^\\s*auto(\\s+auto)?\\s*$/.test(backgroundSize)) {\n        if (backgroundSize == \"contain\") {\n          f = Math.min(orgBox.width / img_width, orgBox.height / img_height);\n          img_width *= f;\n          img_height *= f;\n        } else if (backgroundSize == \"cover\") {\n          f = Math.max(orgBox.width / img_width, orgBox.height / img_height);\n          img_width *= f;\n          img_height *= f;\n        } else {\n          var size = backgroundSize.split(/\\s+/g);\n          // compute width\n          if (/%$/.test(size[0])) {\n            img_width = orgBox.width * parseFloat(size[0]) / 100;\n          } else {\n            img_width = parseFloat(size[0]);\n          }\n          // compute height\n          if (size.length == 1 || size[1] == \"auto\") {\n            img_height = img_width / aspect_ratio;\n          } else if (/%$/.test(size[1])) {\n            img_height = orgBox.height * parseFloat(size[1]) / 100;\n          } else {\n            img_height = parseFloat(size[1]);\n          }\n        }\n      }\n      var pos = String(backgroundPosition);\n\n      // IE sometimes reports single-word positions\n      // https://github.com/telerik/kendo-ui-core/issues/2786\n      //\n      // it seems to switch to percentages when the horizontal\n      // position is not \"center\", therefore we don't handle\n      // multi-word cases here.  All other browsers return\n      // percentages or pixels instead of keywords.  At least\n      // for now...\n      switch (pos) {\n        case \"bottom\":\n          pos = \"50% 100%\";\n          break;\n        case \"top\":\n          pos = \"50% 0\";\n          break;\n        case \"left\":\n          pos = \"0 50%\";\n          break;\n        case \"right\":\n          pos = \"100% 50%\";\n          break;\n        case \"center\":\n          pos = \"50% 50%\";\n          break;\n      }\n      pos = pos.split(/\\s+/);\n      if (pos.length == 1) {\n        pos[1] = \"50%\";\n      }\n      if (/%$/.test(pos[0])) {\n        pos[0] = parseFloat(pos[0]) / 100 * (orgBox.width - img_width);\n      } else {\n        pos[0] = parseFloat(pos[0]);\n      }\n      if (/%$/.test(pos[1])) {\n        pos[1] = parseFloat(pos[1]) / 100 * (orgBox.height - img_height);\n      } else {\n        pos[1] = parseFloat(pos[1]);\n      }\n      var rect = new geo.Rect([orgBox.left + pos[0], orgBox.top + pos[1]], [img_width, img_height]);\n\n      // XXX: background-repeat could be implemented more\n      //      efficiently as a fill pattern (at least for PDF\n      //      output, probably SVG too).\n\n      function rewX() {\n        while (rect.origin.x > box.left) {\n          rect.origin.x -= img_width;\n        }\n      }\n      function rewY() {\n        while (rect.origin.y > box.top) {\n          rect.origin.y -= img_height;\n        }\n      }\n      function repeatX() {\n        while (rect.origin.x < box.right) {\n          renderBG(group, rect.clone());\n          rect.origin.x += img_width;\n        }\n      }\n      if (backgroundRepeat == \"no-repeat\") {\n        renderBG(group, rect);\n      } else if (backgroundRepeat == \"repeat-x\") {\n        rewX();\n        repeatX();\n      } else if (backgroundRepeat == \"repeat-y\") {\n        rewY();\n        while (rect.origin.y < box.bottom) {\n          renderBG(group, rect.clone());\n          rect.origin.y += img_height;\n        }\n      } else if (backgroundRepeat == \"repeat\") {\n        rewX();\n        rewY();\n        var origin = rect.origin.clone();\n        while (rect.origin.y < box.bottom) {\n          rect.origin.x = origin.x;\n          repeatX();\n          rect.origin.y += img_height;\n        }\n      }\n    }\n  }\n  function drawBullet() {\n    var listStyleType = getPropertyValue(style, \"list-style-type\");\n    if (listStyleType == \"none\") {\n      return;\n    }\n    var listStylePosition = getPropertyValue(style, \"list-style-position\");\n    function _drawBullet(f) {\n      saveStyle(element, function () {\n        element.style.position = \"relative\";\n        var bullet = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);\n        bullet.style.position = \"absolute\";\n        bullet.style.boxSizing = \"border-box\";\n        if (listStylePosition == \"outside\") {\n          bullet.style.width = \"6em\";\n          bullet.style.left = \"-6.8em\";\n          bullet.style.textAlign = \"right\";\n        } else {\n          bullet.style.left = \"0px\";\n        }\n        f(bullet);\n        element.insertBefore(bullet, element.firstChild);\n        renderElement(bullet, group);\n        element.removeChild(bullet);\n      });\n    }\n    function elementIndex(f) {\n      var a = element.parentNode.children;\n      var k = element.getAttribute(\"kendo-split-index\");\n      if (k != null) {\n        return f(k | 0, a.length);\n      }\n      for (var i = 0; i < a.length; ++i) {\n        if (a[i] === element) {\n          return f(i, a.length);\n        }\n      }\n    }\n    switch (listStyleType) {\n      case \"circle\":\n      case \"disc\":\n      case \"square\":\n        _drawBullet(function (bullet) {\n          // XXX: the science behind these values is called \"trial and error\".\n          bullet.style.fontSize = \"60%\";\n          bullet.style.lineHeight = \"200%\";\n          bullet.style.paddingRight = \"0.5em\";\n          bullet.style.fontFamily = \"DejaVu Serif\";\n          bullet.innerHTML = {\n            \"disc\": \"\\u25cf\",\n            \"circle\": \"\\u25ef\",\n            \"square\": \"\\u25a0\"\n          }[listStyleType];\n        });\n        break;\n      case \"decimal\":\n      case \"decimal-leading-zero\":\n        _drawBullet(function (bullet) {\n          elementIndex(function (idx) {\n            ++idx;\n            if (listStyleType == \"decimal-leading-zero\" && idx < 10) {\n              idx = \"0\" + idx;\n            }\n            bullet.innerHTML = idx + \".\";\n          });\n        });\n        break;\n      case \"lower-roman\":\n      case \"upper-roman\":\n        _drawBullet(function (bullet) {\n          elementIndex(function (idx) {\n            idx = arabicToRoman(idx + 1);\n            if (listStyleType == \"upper-roman\") {\n              idx = idx.toUpperCase();\n            }\n            bullet.innerHTML = idx + \".\";\n          });\n        });\n        break;\n      case \"lower-latin\":\n      case \"lower-alpha\":\n      case \"upper-latin\":\n      case \"upper-alpha\":\n        _drawBullet(function (bullet) {\n          elementIndex(function (idx) {\n            idx = alphaNumeral(idx);\n            if (/^upper/i.test(listStyleType)) {\n              idx = idx.toUpperCase();\n            }\n            bullet.innerHTML = idx + \".\";\n          });\n        });\n        break;\n    }\n  }\n\n  // draws a single border box\n  function drawOneBox(box, isFirst, isLast) {\n    if (box.width === 0 || box.height === 0) {\n      return;\n    }\n    drawBackground(box);\n    var shouldDrawLeft = left.width > 0 && (isFirst && dir == \"ltr\" || isLast && dir == \"rtl\");\n    var shouldDrawRight = right.width > 0 && (isLast && dir == \"ltr\" || isFirst && dir == \"rtl\");\n\n    // The most general case is that the 4 borders have different widths and border\n    // radiuses.  The way that is handled is by drawing 3 Paths for each border: the\n    // straight line, and two round corners which represent half of the entire rounded\n    // corner.  To simplify code those shapes are drawed at origin (by the drawEdge\n    // function), then translated/rotated into the right position.\n    //\n    // However, this leads to poor results due to rounding in the simpler cases where\n    // borders are straight lines.  Therefore we handle a few such cases separately with\n    // straight lines. C^wC^wC^w -- nope, scratch that.  poor rendering was because of a bug\n    // in Chrome (getClientRects() returns rounded integer values rather than exact floats.\n    // web dev is still a ghetto.)\n\n    // first, just in case there is no border...\n    if (top.width === 0 && left.width === 0 && right.width === 0 && bottom.width === 0) {\n      return;\n    }\n\n    // START paint borders\n    // if all borders have equal colors...\n    if (top.color == right.color && top.color == bottom.color && top.color == left.color) {\n      // if same widths too, we can draw the whole border by stroking a single path.\n      if (top.width == right.width && top.width == bottom.width && top.width == left.width) {\n        if (shouldDrawLeft && shouldDrawRight) {\n          // reduce box by half the border width, so we can draw it by stroking.\n          box = innerBox(box, top.width / 2);\n\n          // adjust the border radiuses, again by top.width/2, and make the path element.\n          var path = elementRoundBox(element, box, top.width / 2);\n          path.options.stroke = {\n            color: top.color,\n            width: top.width\n          };\n          group.append(path);\n          return;\n        }\n      }\n    }\n\n    // if border radiuses are zero and widths are at most one pixel, we can again use simple\n    // paths.\n    if (rTL0.x === 0 && rTR0.x === 0 && rBR0.x === 0 && rBL0.x === 0) {\n      // alright, 1.9px will do as well.  the difference in color blending should not be\n      // noticeable.\n      if (top.width < 2 && left.width < 2 && right.width < 2 && bottom.width < 2) {\n        // top border\n        if (top.width > 0) {\n          group.append(new Path({\n            stroke: {\n              width: top.width,\n              color: top.color\n            }\n          }).moveTo(box.left, box.top + top.width / 2).lineTo(box.right, box.top + top.width / 2));\n        }\n\n        // bottom border\n        if (bottom.width > 0) {\n          group.append(new Path({\n            stroke: {\n              width: bottom.width,\n              color: bottom.color\n            }\n          }).moveTo(box.left, box.bottom - bottom.width / 2).lineTo(box.right, box.bottom - bottom.width / 2));\n        }\n\n        // left border\n        if (shouldDrawLeft) {\n          group.append(new Path({\n            stroke: {\n              width: left.width,\n              color: left.color\n            }\n          }).moveTo(box.left + left.width / 2, box.top).lineTo(box.left + left.width / 2, box.bottom));\n        }\n\n        // right border\n        if (shouldDrawRight) {\n          group.append(new Path({\n            stroke: {\n              width: right.width,\n              color: right.color\n            }\n          }).moveTo(box.right - right.width / 2, box.top).lineTo(box.right - right.width / 2, box.bottom));\n        }\n        return;\n      }\n    }\n    // END paint borders\n\n    var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);\n    var rTL = tmp.tl;\n    var rTR = tmp.tr;\n    var rBR = tmp.br;\n    var rBL = tmp.bl;\n\n    // top border\n    drawEdge(top.color, box.width, top.width, left.width, right.width, rTL, rTR, [1, 0, 0, 1, box.left, box.top]);\n\n    // bottom border\n    drawEdge(bottom.color, box.width, bottom.width, right.width, left.width, rBR, rBL, [-1, 0, 0, -1, box.right, box.bottom]);\n\n    // for left/right borders we need to invert the border-radiuses\n    function inv(p) {\n      return {\n        x: p.y,\n        y: p.x\n      };\n    }\n\n    // left border\n    drawEdge(left.color, box.height, left.width, bottom.width, top.width, inv(rBL), inv(rTL), [0, -1, 1, 0, box.left, box.bottom]);\n\n    // right border\n    drawEdge(right.color, box.height, right.width, top.width, bottom.width, inv(rTR), inv(rBR), [0, 1, -1, 0, box.right, box.top]);\n  }\n}\nfunction gradientRenderer(gradient) {\n  return function (group, rect) {\n    var width = rect.width(),\n      height = rect.height();\n    switch (gradient.type) {\n      case \"linear\":\n        // figure out the angle.\n        var angle = gradient.angle != null ? gradient.angle : Math.PI;\n        switch (gradient.to) {\n          case \"top\":\n            angle = 0;\n            break;\n          case \"left\":\n            angle = -Math.PI / 2;\n            break;\n          case \"bottom\":\n            angle = Math.PI;\n            break;\n          case \"right\":\n            angle = Math.PI / 2;\n            break;\n          case \"top left\":\n          case \"left top\":\n            angle = -Math.atan2(height, width);\n            break;\n          case \"top right\":\n          case \"right top\":\n            angle = Math.atan2(height, width);\n            break;\n          case \"bottom left\":\n          case \"left bottom\":\n            angle = Math.PI + Math.atan2(height, width);\n            break;\n          case \"bottom right\":\n          case \"right bottom\":\n            angle = Math.PI - Math.atan2(height, width);\n            break;\n        }\n        if (gradient.reverse) {\n          angle -= Math.PI;\n        }\n\n        // limit the angle between 0..2PI\n        angle %= 2 * Math.PI;\n        if (angle < 0) {\n          angle += 2 * Math.PI;\n        }\n\n        // compute gradient's start/end points.  here len is the length of the gradient line\n        // and x,y is the end point relative to the center of the rectangle in conventional\n        // (math) axis direction.\n\n        // this is the original (unscaled) length of the gradient line.  needed to deal with\n        // absolutely positioned color stops.  formula from the CSS spec:\n        // http://dev.w3.org/csswg/css-images-3/#linear-gradient-syntax\n        var pxlen = Math.abs(width * Math.sin(angle)) + Math.abs(height * Math.cos(angle));\n\n        // The math below is pretty simple, but it took a while to figure out.  We compute x\n        // and y, the *end* of the gradient line.  However, we want to transform them into\n        // element-based coordinates (SVG's gradientUnits=\"objectBoundingBox\").  That means,\n        // x=0 is the left edge, x=1 is the right edge, y=0 is the top edge and y=1 is the\n        // bottom edge.\n        //\n        // A naive approach would use the original angle for these calculations.  Say we'd\n        // like to draw a gradient angled at 45deg in a 100x400 box.  When we use\n        // objectBoundingBox, the renderer will draw it in a 1x1 *square* box, and then\n        // scale that to the desired dimensions.  The 45deg angle will look more like 70deg\n        // after scaling.  SVG (http://www.w3.org/TR/SVG/pservers.html#LinearGradients) says\n        // the following:\n        //\n        //     When gradientUnits=\"objectBoundingBox\" and 'gradientTransform' is the\n        //     identity matrix, the normal of the linear gradient is perpendicular to the\n        //     gradient vector in object bounding box space (i.e., the abstract coordinate\n        //     system where (0,0) is at the top/left of the object bounding box and (1,1) is\n        //     at the bottom/right of the object bounding box). When the object's bounding\n        //     box is not square, the gradient normal which is initially perpendicular to\n        //     the gradient vector within object bounding box space may render\n        //     non-perpendicular relative to the gradient vector in user space. If the\n        //     gradient vector is parallel to one of the axes of the bounding box, the\n        //     gradient normal will remain perpendicular. This transformation is due to\n        //     application of the non-uniform scaling transformation from bounding box space\n        //     to user space.\n        //\n        // which is an extremely long and confusing way to tell what I just said above.\n        //\n        // For this reason we need to apply the reverse scaling to the original angle, so\n        // that when it'll finally be rendered it'll actually be at the desired slope.  Now\n        // I'll let you figure out the math yourself.\n\n        var scaledAngle = Math.atan(width * Math.tan(angle) / height);\n        var sin = Math.sin(scaledAngle),\n          cos = Math.cos(scaledAngle);\n        var len = Math.abs(sin) + Math.abs(cos);\n        var x = len / 2 * sin;\n        var y = len / 2 * cos;\n\n        // Because of the arctangent, our scaledAngle ends up between -PI/2..PI/2, possibly\n        // losing the intended direction of the gradient.  The following fixes it.\n        if (angle > Math.PI / 2 && angle <= 3 * Math.PI / 2) {\n          x = -x;\n          y = -y;\n        }\n\n        // compute the color stops.\n        var implicit = [],\n          right = 0;\n        var stops = gradient.stops.map(function (s, i) {\n          var offset = s.percent;\n          if (offset) {\n            offset = parseFloat(offset) / 100;\n          } else if (s.length) {\n            offset = parseFloat(s.length) / pxlen;\n          } else if (i === 0) {\n            offset = 0;\n          } else if (i == gradient.stops.length - 1) {\n            offset = 1;\n          }\n          var stop = {\n            color: s.color.toCssRgba(),\n            offset: offset\n          };\n          if (offset != null) {\n            right = offset;\n            // fix implicit offsets\n            implicit.forEach(function (s, i) {\n              var stop = s.stop;\n              stop.offset = s.left + (right - s.left) * (i + 1) / (implicit.length + 1);\n            });\n            implicit = [];\n          } else {\n            implicit.push({\n              left: right,\n              stop: stop\n            });\n          }\n          return stop;\n        });\n        var start = [0.5 - x, 0.5 + y];\n        var end = [0.5 + x, 0.5 - y];\n\n        // finally, draw it.\n        group.append(Path.fromRect(rect).stroke(null).fill(new LinearGradient({\n          start: start,\n          end: end,\n          stops: stops,\n          userSpace: false\n        })));\n        break;\n      case \"radial\":\n        // XXX:\n        if (window.console && window.console.log) {\n          window.console.log(\"Radial gradients are not yet supported in HTML renderer\");\n        }\n        break;\n    }\n  };\n}\nfunction maybeRenderWidget(element, group) {\n  var visual;\n  if (element._kendoExportVisual) {\n    visual = element._kendoExportVisual();\n  } else if (window.kendo && window.kendo.jQuery && element.getAttribute(window.kendo.attr(\"role\"))) {\n    var widget = window.kendo.widgetInstance(window.kendo.jQuery(element));\n    if (widget && (widget.exportDOMVisual || widget.exportVisual)) {\n      if (widget.exportDOMVisual) {\n        visual = widget.exportDOMVisual();\n      } else {\n        visual = widget.exportVisual();\n      }\n    }\n  }\n  if (!visual) {\n    return false;\n  }\n  var wrap = new Group();\n  wrap.children.push(visual);\n  var bbox = element.getBoundingClientRect();\n  wrap.transform(geo.transform().translate(bbox.left, bbox.top));\n  group.append(wrap);\n  return true;\n}\nfunction renderImage(element, url, group) {\n  var box = getContentBox(element);\n  var rect = new geo.Rect([box.left, box.top], [box.width, box.height]);\n  var image = new Image(url, rect);\n  setClipping(image, elementRoundBox(element, box, \"content\"));\n  group.append(image);\n}\nfunction zIndexSort(a, b) {\n  var sa = getComputedStyle(a);\n  var sb = getComputedStyle(b);\n  var za = parseFloat(getPropertyValue(sa, \"z-index\"));\n  var zb = parseFloat(getPropertyValue(sb, \"z-index\"));\n  var pa = getPropertyValue(sa, \"position\");\n  var pb = getPropertyValue(sb, \"position\");\n  if (isNaN(za) && isNaN(zb)) {\n    if (/static|absolute/.test(pa) && /static|absolute/.test(pb)) {\n      return 0;\n    }\n    if (pa == \"static\") {\n      return -1;\n    }\n    if (pb == \"static\") {\n      return 1;\n    }\n    return 0;\n  }\n  if (isNaN(za)) {\n    return zb === 0 ? 0 : zb > 0 ? -1 : 1;\n  }\n  if (isNaN(zb)) {\n    return za === 0 ? 0 : za > 0 ? 1 : -1;\n  }\n  return parseFloat(za) - parseFloat(zb);\n}\nfunction isFormField(element) {\n  return /^(?:textarea|select|input)$/i.test(element.tagName);\n}\nfunction getSelectedOption(element) {\n  if (element.selectedOptions && element.selectedOptions.length > 0) {\n    return element.selectedOptions[0];\n  }\n  return element.options[element.selectedIndex];\n}\nfunction renderCheckbox(element, group) {\n  var style = getComputedStyle(element);\n  var color = getPropertyValue(style, \"color\");\n  var box = element.getBoundingClientRect();\n  if (element.type == \"checkbox\") {\n    group.append(Path.fromRect(new geo.Rect([box.left + 1, box.top + 1], [box.width - 2, box.height - 2])).stroke(color, 1));\n    if (element.checked) {\n      // fill a rectangle inside?  looks kinda ugly.\n      // group.append(\n      //     Path.fromRect(\n      //         new geo.Rect([ box.left+4, box.top+4 ],\n      //                      [ box.width-8, box.height-8])\n      //     ).fill(color).stroke(null)\n      // );\n\n      // let's draw a checkmark instead.  artistic, eh?\n      group.append(new Path().stroke(color, 1.2).moveTo(box.left + 0.22 * box.width, box.top + 0.55 * box.height).lineTo(box.left + 0.45 * box.width, box.top + 0.75 * box.height).lineTo(box.left + 0.78 * box.width, box.top + 0.22 * box.width));\n    }\n  } else {\n    group.append(new Circle(new geo.Circle([(box.left + box.right) / 2, (box.top + box.bottom) / 2], Math.min(box.width - 2, box.height - 2) / 2)).stroke(color, 1));\n    if (element.checked) {\n      group.append(new Circle(new geo.Circle([(box.left + box.right) / 2, (box.top + box.bottom) / 2], Math.min(box.width - 8, box.height - 8) / 2)).fill(color).stroke(null));\n    }\n  }\n}\nfunction renderFormField(element, group) {\n  var tag = element.tagName.toLowerCase();\n  if (tag == \"input\" && (element.type == \"checkbox\" || element.type == \"radio\")) {\n    return renderCheckbox(element, group);\n  }\n  var p = element.parentNode;\n  var doc = element.ownerDocument;\n  var el = doc.createElement(KENDO_PSEUDO_ELEMENT);\n  var option;\n  el.style.cssText = getCssText(getComputedStyle(element));\n  if (tag == \"input\") {\n    el.style.whiteSpace = \"pre\";\n  }\n  if (tag == \"select\" || tag == \"textarea\") {\n    el.style.overflow = \"auto\";\n  }\n  if (tag == \"select\") {\n    if (element.multiple) {\n      for (var i = 0; i < element.options.length; ++i) {\n        option = doc.createElement(KENDO_PSEUDO_ELEMENT);\n        option.style.cssText = getCssText(getComputedStyle(element.options[i]));\n        option.style.display = \"block\"; // IE9 messes up without this\n        option.textContent = element.options[i].textContent;\n        el.appendChild(option);\n      }\n    } else {\n      option = getSelectedOption(element);\n      if (option) {\n        el.textContent = option.textContent;\n      }\n    }\n  } else {\n    el.textContent = element.value;\n  }\n  p.insertBefore(el, element);\n  el.scrollLeft = element.scrollLeft;\n  el.scrollTop = element.scrollTop;\n\n  // must temporarily hide the original element, otherwise it\n  // may affect layout of the fake element we want to render.\n  element.style.display = \"none\";\n  renderContents(el, group);\n  element.style.display = \"\";\n  p.removeChild(el);\n}\nfunction serializeSVG(element) {\n  var serializer = new window.XMLSerializer();\n  var xml = serializer.serializeToString(element);\n  if (browser.mozilla && !(element.getAttribute(\"width\") && element.getAttribute(\"height\"))) {\n    var doc = new window.DOMParser().parseFromString(xml, \"image/svg+xml\");\n    var svg = doc.documentElement;\n    var box = getContentBox(element);\n    svg.setAttribute(\"width\", box.width);\n    svg.setAttribute(\"height\", box.height);\n    xml = serializer.serializeToString(svg);\n  }\n  return xml;\n}\nfunction renderContents(element, group) {\n  if (nodeInfo._stackingContext.element === element) {\n    // the group that was set in pushNodeInfo might have\n    // changed due to clipping/transforms, update it here.\n    nodeInfo._stackingContext.group = group;\n  }\n  switch (element.tagName.toLowerCase()) {\n    case \"img\":\n      renderImage(element, element.src, group);\n      break;\n    case \"svg\":\n      var xml = serializeSVG(element);\n      var dataURL = \"data:image/svg+xml;base64,\" + encodeBase64(xml);\n      renderImage(element, dataURL, group);\n      break;\n    case \"canvas\":\n      try {\n        renderImage(element, element.toDataURL(\"image/png\"), group);\n      } catch (ex) {\n        // tainted; can't draw it, ignore.\n      }\n      break;\n    case \"textarea\":\n    case \"input\":\n    case \"select\":\n      renderFormField(element, group);\n      break;\n    default:\n      var children = [],\n        floats = [],\n        positioned = [];\n      for (var i = element.firstChild; i; i = i.nextSibling) {\n        switch (i.nodeType) {\n          case 3:\n            // Text\n            if (/\\S/.test(i.data)) {\n              renderText(element, i, group);\n            }\n            break;\n          case 1:\n            // Element\n            var style = getComputedStyle(i);\n            var floating = getPropertyValue(style, \"float\");\n            var position = getPropertyValue(style, \"position\");\n            if (position != \"static\") {\n              positioned.push(i);\n            } else if (floating != \"none\") {\n              floats.push(i);\n            } else {\n              children.push(i);\n            }\n            break;\n        }\n      }\n      mergeSort(children, zIndexSort).forEach(function (el) {\n        renderElement(el, group);\n      });\n      mergeSort(floats, zIndexSort).forEach(function (el) {\n        renderElement(el, group);\n      });\n      mergeSort(positioned, zIndexSort).forEach(function (el) {\n        renderElement(el, group);\n      });\n  }\n}\nfunction renderText(element, node, group) {\n  if (emptyClipbox()) {\n    return;\n  }\n  var style = getComputedStyle(element);\n  if (parseFloat(getPropertyValue(style, \"text-indent\")) < -500) {\n    // assume it should not be displayed.  the slider's\n    // draggable handle displays a Drag text for some reason,\n    // having text-indent: -3333px.\n    return;\n  }\n  var text = node.data;\n  var start = 0;\n  var end = text.search(/\\S\\s*$/) + 1;\n  if (!end) {\n    return; // whitespace-only node\n  }\n\n  var fontSize = getPropertyValue(style, \"font-size\");\n  var lineHeight = getPropertyValue(style, \"line-height\");\n\n  // simply getPropertyValue(\"font\") doesn't work in Firefox :-\\\n  var font = [getPropertyValue(style, \"font-style\"), getPropertyValue(style, \"font-variant\"), getPropertyValue(style, \"font-weight\"), fontSize,\n  // no need for line height here; it breaks layout in FF\n  getPropertyValue(style, \"font-family\")].join(\" \");\n  fontSize = parseFloat(fontSize);\n  lineHeight = parseFloat(lineHeight);\n  if (fontSize === 0 || isNaN(fontSize)) {\n    return;\n  }\n  var color = getPropertyValue(style, \"color\");\n  var range = element.ownerDocument.createRange();\n  var align = getPropertyValue(style, \"text-align\");\n  var isJustified = align == \"justify\";\n  var columnCount = getPropertyValue(style, \"column-count\", 1);\n  var whiteSpace = getPropertyValue(style, \"white-space\");\n  var textTransform = getPropertyValue(style, \"text-transform\");\n\n  // A line of 500px, with a font of 12px, contains an average of 80 characters, but since we\n  // err, we'd like to guess a bigger number rather than a smaller one.  Multiplying by 5\n  // seems to be a good option.\n  var estimateLineLength = element.getBoundingClientRect().width / fontSize * 5;\n  if (estimateLineLength === 0) {\n    estimateLineLength = 500;\n  }\n\n  // we'll maintain this so we can workaround bugs in Chrome's Range.getClientRects\n  // https://github.com/telerik/kendo/issues/5740\n  var prevLineBottom = null;\n  var underline = nodeInfo[\"underline\"];\n  var lineThrough = nodeInfo[\"line-through\"];\n  var overline = nodeInfo[\"overline\"];\n  var underlineOffset = nodeInfo[\"underline-offset\"];\n  if (underline) {\n    forEachRect(decorateUnder);\n  }\n\n  // doChunk returns true when all text has been rendered\n  while (!doChunk()) {}\n  if (lineThrough || overline) {\n    forEachRect(decorateOver);\n  }\n  return; // only function declarations after this line\n\n  function forEachRect(callback) {\n    range.selectNode(node);\n    var clientRects = slice(range.getClientRects());\n    forEachRect = function (cb) {\n      return clientRects.forEach(cb);\n    };\n    forEachRect(callback);\n  }\n  function actuallyGetRangeBoundingRect(range) {\n    // XXX: to be revised when this Chrome bug is fixed:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=612459\n    if (microsoft || browser.chrome || browser.safari) {\n      // Workaround browser bugs: IE and Chrome would sometimes\n      // return 0 or 1-width rectangles before or after the main\n      // one.  https://github.com/telerik/kendo/issues/4674\n\n      // Actually Chrome 50 got worse, since the rectangles can now have the width of a\n      // full character, making it hard to tell whether it's a bogus rectangle or valid\n      // selection location.  The workaround is to ignore rectangles that fall on the\n      // previous line.  https://github.com/telerik/kendo/issues/5740\n      var rectangles = range.getClientRects(),\n        box = {\n          top: Infinity,\n          right: -Infinity,\n          bottom: -Infinity,\n          left: Infinity\n        },\n        done = false;\n      for (var i = 0; i < rectangles.length; ++i) {\n        var b = rectangles[i];\n        if (b.width <= 1 || b.bottom === prevLineBottom) {\n          continue; // bogus rectangle\n        }\n\n        box.left = Math.min(b.left, box.left);\n        box.top = Math.min(b.top, box.top);\n        box.right = Math.max(b.right, box.right);\n        box.bottom = Math.max(b.bottom, box.bottom);\n        done = true;\n      }\n      if (!done) {\n        return range.getBoundingClientRect();\n      }\n      box.width = box.right - box.left;\n      box.height = box.bottom - box.top;\n      return box;\n    }\n    return range.getBoundingClientRect();\n  }\n\n  // Render a chunk of text, typically one line (but for justified text we render each word as\n  // a separate Text object, because spacing is variable).  Returns true when it finished the\n  // current node.  After each chunk it updates `start` to just after the last rendered\n  // character.\n  function doChunk() {\n    var origStart = start;\n    var box,\n      pos = text.substr(start).search(/\\S/);\n    start += pos;\n    if (pos < 0 || start >= end) {\n      return true;\n    }\n\n    // Select a single character to determine the height of a line of text.  The box.bottom\n    // will be essential for us to figure out where the next line begins.\n    range.setStart(node, start);\n    range.setEnd(node, start + 1);\n    box = actuallyGetRangeBoundingRect(range);\n\n    // for justified text we must split at each space, because space has variable width.\n    var found = false;\n    if (isJustified || columnCount > 1) {\n      pos = text.substr(start).search(/\\s/);\n      if (pos >= 0) {\n        // we can only split there if it's on the same line, otherwise we'll fall back\n        // to the default mechanism (see findEOL below).\n        range.setEnd(node, start + pos);\n        var r = actuallyGetRangeBoundingRect(range);\n        if (r.bottom == box.bottom) {\n          box = r;\n          found = true;\n          start += pos;\n        }\n      }\n    }\n    if (!found) {\n      // This code does three things: (1) it selects one line of text in `range`, (2) it\n      // leaves the bounding rect of that line in `box` and (3) it returns the position\n      // just after the EOL.  We know where the line starts (`start`) but we don't know\n      // where it ends.  To figure this out, we select a piece of text and look at the\n      // bottom of the bounding box.  If it changes, we have more than one line selected\n      // and should retry with a smaller selection.\n      //\n      // To speed things up, we first try to select all text in the node (`start` ->\n      // `end`).  If there's more than one line there, then select only half of it.  And\n      // so on.  When we find a value for `end` that fits in one line, we try increasing\n      // it (also in halves) until we get to the next line.  The algorithm stops when the\n      // right side of the bounding box does not change.\n      //\n      // One more thing to note is that everything happens in a single Text DOM node.\n      // There's no other tags inside it, therefore the left/top coordinates of the\n      // bounding box will not change.\n      pos = function findEOL(min, eol, max) {\n        range.setEnd(node, eol);\n        var r = actuallyGetRangeBoundingRect(range);\n        if (r.bottom != box.bottom && min < eol) {\n          return findEOL(min, min + eol >> 1, eol);\n        } else if (r.right != box.right) {\n          box = r;\n          if (eol < max) {\n            return findEOL(eol, eol + max >> 1, max);\n          } else {\n            return eol;\n          }\n        } else {\n          return eol;\n        }\n      }(start, Math.min(end, start + estimateLineLength), end);\n      if (pos == start) {\n        // if EOL is at the start, then no more text fits on this line.  Skip the\n        // remainder of this node entirely to avoid a stack overflow.\n        return true;\n      }\n      start = pos;\n      pos = range.toString().search(/\\s+$/);\n      if (pos === 0) {\n        return false; // whitespace only; we should not get here.\n      }\n\n      if (pos > 0) {\n        // eliminate trailing whitespace\n        range.setEnd(node, range.startOffset + pos);\n        box = actuallyGetRangeBoundingRect(range);\n      }\n    }\n\n    // another workaround for IE: if we rely on getBoundingClientRect() we'll overlap with the bullet for LI\n    // elements.  Calling getClientRects() and using the *first* rect appears to give us the correct location.\n    // Note: not to be used in Chrome as it randomly returns a zero-width rectangle from the previous line.\n    if (microsoft) {\n      box = range.getClientRects()[0];\n    }\n    var str = range.toString();\n    if (!/^(?:pre|pre-wrap)$/i.test(whiteSpace)) {\n      // node with non-significant space -- collapse whitespace.\n      str = str.replace(/\\s+/g, \" \");\n    } else if (/\\t/.test(str)) {\n      // with significant whitespace we need to do something about literal TAB characters.\n      // There's no TAB glyph in a font so they would be rendered in PDF as an empty box,\n      // and the whole text will stretch to fill the original width.  The core PDF lib\n      // does not have sufficient context to deal with it.\n\n      // calculate the starting column here, since we initially discarded any whitespace.\n      var cc = 0;\n      for (pos = origStart; pos < range.startOffset; ++pos) {\n        var code = text.charCodeAt(pos);\n        if (code == 9) {\n          // when we meet a TAB we must round up to the next tab stop.\n          // in all browsers TABs seem to be 8 characters.\n          cc += 8 - cc % 8;\n        } else if (code == 10 || code == 13) {\n          // just in case we meet a newline we must restart.\n          cc = 0;\n        } else {\n          // ordinary character --> advance one column\n          cc++;\n        }\n      }\n\n      // based on starting column, replace any TAB characters in the string we actually\n      // have to display with spaces so that they align to columns multiple of 8.\n      while ((pos = str.search(\"\\t\")) >= 0) {\n        var indent = \"        \".substr(0, 8 - (cc + pos) % 8);\n        str = str.substr(0, pos) + indent + str.substr(pos + 1);\n      }\n    }\n    if (!found) {\n      prevLineBottom = box.bottom;\n    }\n    drawText(str, box);\n  }\n  function drawText(str, box) {\n    // In IE the box height will be approximately lineHeight, while in\n    // other browsers it'll (correctly) be the height of the bounding\n    // box for the current text/font.  Which is to say, IE sucks again.\n    // The only good solution I can think of is to measure the text\n    // ourselves and center the bounding box.\n    if (microsoft && !isNaN(lineHeight)) {\n      var height = getFontHeight(font);\n      var top = (box.top + box.bottom - height) / 2;\n      box = {\n        top: top,\n        right: box.right,\n        bottom: top + height,\n        left: box.left,\n        height: height,\n        width: box.right - box.left\n      };\n    }\n\n    // var path = new Path({ stroke: { color: \"red\" }});\n    // path.moveTo(box.left, box.top)\n    //     .lineTo(box.right, box.top)\n    //     .lineTo(box.right, box.bottom)\n    //     .lineTo(box.left, box.bottom)\n    //     .close();\n    // group.append(path);\n\n    switch (textTransform) {\n      case \"uppercase\":\n        str = str.toUpperCase();\n        break;\n      case \"lowercase\":\n        str = str.toLowerCase();\n        break;\n      case \"capitalize\":\n        str = str.replace(/(?:^|\\s)\\S/g, function (l) {\n          return l.toUpperCase();\n        });\n        break;\n    }\n    var text = new TextRect(str, new geo.Rect([box.left, box.top], [box.width, box.height]), {\n      font: font,\n      fill: {\n        color: color\n      }\n    });\n    group.append(text);\n  }\n  function drawTextLine(lineWidth, textBox, color, ypos) {\n    if (color) {\n      var path = new Path({\n        stroke: {\n          width: lineWidth,\n          color: color\n        }\n      });\n      ypos -= lineWidth;\n      path.moveTo(textBox.left, ypos).lineTo(textBox.right, ypos);\n      group.append(path);\n    }\n  }\n  function decorateOver(box) {\n    var width = fontSize / 12;\n    drawTextLine(width, box, lineThrough, box.bottom - box.height / 2.7);\n    drawTextLine(width, box, overline, box.top);\n  }\n  function decorateUnder(box) {\n    var width = fontSize / 12;\n    var underlinePos = box.bottom;\n    if (underlineOffset != null) {\n      underlinePos += underlineOffset;\n    } else {\n      underlinePos += width; // for \"auto\" it seems better to add line width\n    }\n\n    drawTextLine(width, box, underline, underlinePos);\n  }\n}\nfunction groupInStackingContext(element, group, zIndex) {\n  var main;\n  if (zIndex != \"auto\") {\n    // use the current stacking context\n    main = nodeInfo._stackingContext.group;\n    zIndex = parseFloat(zIndex);\n  } else {\n    // normal flow â€” use given container.  we still have to\n    // figure out where should we insert this element with the\n    // assumption that its z-index is zero, as the group might\n    // already contain elements with higher z-index.\n    main = group;\n    zIndex = 0;\n  }\n  var a = main.children;\n  for (var i = 0; i < a.length; ++i) {\n    if (a[i]._dom_zIndex != null && a[i]._dom_zIndex > zIndex) {\n      break;\n    }\n  }\n  var tmp = new Group();\n  main.insert(i, tmp);\n  tmp._dom_zIndex = zIndex;\n  if (main !== group) {\n    // console.log(\"Placing\", element, \"in\", nodeInfo._stackingContext.element, \"at position\", i, \" / \", a.length);\n    // console.log(a.slice(i+1));\n\n    // if (nodeInfo._matrix) {\n    //     tmp.transform(nodeInfo._matrix);\n    // }\n    if (nodeInfo._clipbox) {\n      var m = nodeInfo._matrix.invert();\n      var r = nodeInfo._clipbox.transformCopy(m);\n      setClipping(tmp, Path.fromRect(r));\n      // console.log(r);\n      // tmp.append(Path.fromRect(r));\n      // tmp.append(new Text(element.className || element.id, r.topLeft()));\n    }\n  }\n\n  return tmp;\n}\nfunction renderElement(element, container) {\n  var style = getComputedStyle(element);\n  updateCounters(style);\n  if (/^(style|script|link|meta|iframe|col|colgroup)$/i.test(element.tagName)) {\n    return;\n  }\n  if (nodeInfo._clipbox == null) {\n    return;\n  }\n  var opacity = parseFloat(getPropertyValue(style, \"opacity\"));\n  var visibility = getPropertyValue(style, \"visibility\");\n  var display = getPropertyValue(style, \"display\");\n  if (opacity === 0 || visibility == \"hidden\" || display == \"none\") {\n    return;\n  }\n  var tr = getTransform(style);\n  var group;\n  var zIndex = getPropertyValue(style, \"z-index\");\n  if ((tr || opacity < 1) && zIndex == \"auto\") {\n    zIndex = 0;\n  }\n  group = groupInStackingContext(element, container, zIndex);\n\n  // XXX: remove at some point\n  // group._pdfElement = element;\n  // group.options._pdfDebug = \"\";\n  // if (element.id) {\n  //     group.options._pdfDebug = \"#\" + element.id;\n  // }\n  // if (element.className) {\n  //     group.options._pdfDebug += \".\" + element.className.split(\" \").join(\".\");\n  // }\n\n  if (opacity < 1) {\n    group.opacity(opacity * group.opacity());\n  }\n  pushNodeInfo(element, style, group);\n  if (!tr) {\n    _renderWithPseudoElements(element, group);\n  } else {\n    saveStyle(element, function () {\n      // must clear transform, so getBoundingClientRect returns correct values.\n      pleaseSetPropertyValue(element.style, \"transform\", \"none\", \"important\");\n\n      // must also clear transitions, so correct values are returned *immediately*\n      pleaseSetPropertyValue(element.style, \"transition\", \"none\", \"important\");\n\n      // the presence of any transform makes it behave like it had position: relative,\n      // because why not.\n      // http://meyerweb.com/eric/thoughts/2011/09/12/un-fixing-fixed-elements-with-css-transforms/\n      if (getPropertyValue(style, \"position\") == \"static\") {\n        // but only if it's not already positioned. :-/\n        pleaseSetPropertyValue(element.style, \"position\", \"relative\", \"important\");\n      }\n\n      // must translate to origin before applying the CSS\n      // transformation, then translate back.\n      var bbox = element.getBoundingClientRect();\n      var x = bbox.left + tr.origin[0];\n      var y = bbox.top + tr.origin[1];\n      var m = [1, 0, 0, 1, -x, -y];\n      m = mmul(m, tr.matrix);\n      m = mmul(m, [1, 0, 0, 1, x, y]);\n      m = setTransform(group, m);\n      nodeInfo._matrix = nodeInfo._matrix.multiplyCopy(m);\n      _renderWithPseudoElements(element, group);\n    });\n  }\n  popNodeInfo();\n\n  //drawDebugBox(element.getBoundingClientRect(), container);\n}\n\n// function drawDebugBox(box, group, color) {\n//     var path = Path.fromRect(new geo.Rect([ box.left, box.top ], [ box.width, box.height ]));\n//     if (color) {\n//         path.stroke(color);\n//     }\n//     group.append(path);\n// }\n\n// function dumpTextNode(node) {\n//     var txt = node.data.replace(/^\\s+/, \"\");\n//     if (txt.length < 100) {\n//         console.log(node.data.length + \": |\" + txt);\n//     } else {\n//         console.log(node.data.length + \": |\" + txt.substr(0, 50) + \"|...|\" + txt.substr(-50));\n//     }\n// }\n\nfunction mmul(a, b) {\n  var a1 = a[0],\n    b1 = a[1],\n    c1 = a[2],\n    d1 = a[3],\n    e1 = a[4],\n    f1 = a[5];\n  var a2 = b[0],\n    b2 = b[1],\n    c2 = b[2],\n    d2 = b[3],\n    e2 = b[4],\n    f2 = b[5];\n  return [a1 * a2 + b1 * c2, a1 * b2 + b1 * d2, c1 * a2 + d1 * c2, c1 * b2 + d1 * d2, e1 * a2 + f1 * c2 + e2, e1 * b2 + f1 * d2 + f2];\n}\nexport { drawDOM, drawText, getFontFaces };","map":{"version":3,"names":["geo","PDF","arabicToRoman","createPromise","measureText","mergeSort","parseColor","utils_parseColor","support","template","compileTemplate","Path","Text","Group","Image","Circle","LinearGradient","encodeBase64","browser","slice","thing","Array","prototype","call","KENDO_PSEUDO_ELEMENT","IMAGE_CACHE","nodeInfo","_root","inBrowser","window","microsoft","msie","edge","TextRect","str","rect","options","getOrigin","_pdfRect","__proto__","Object","create","constructor","rawBBox","addClass","el","cls","classList","add","className","removeClass","remove","split","reduce","a","word","push","join","setCSS","styles","keys","forEach","key","style","matches","Element","p","selector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","s","indexOf","document","querySelectorAll","closest","test","String","nodeType","parentNode","cloneNodes","$","clone","cloneNode","$el","$clone","i","data","tagName","getContext","drawImage","removeAttribute","value","checked","selected","firstChild","nextSibling","appendChild","dive","node","_kendoExportVisual","canvases","length","canvas","orig","kendo","jQuery","getXY","x","y","isArray","drawDOM","element","promise","reject","getComputedStyle","Error","defineFont","getFontFaces","ownerDocument","scale","doOne","group","pos","getBoundingClientRect","setTransform","left","top","_clipbox","_matrix","Matrix","unit","_stackingContext","avoidLinks","_avoidLinks","renderElement","cacheImages","forceBreak","forcePageBreak","hasPaperSize","paperSize","paperOptions","getPaperOptions","def","pageWidth","pageHeight","margin","hasMargin","Boolean","right","bottom","pdf","multiPage","_ignoreMargin","handlePageBreaks","progress","canceled","pageNum","next","pages","page","append","totalPages","cancel","setTimeout","container","removeChild","resolve","makeTemplate","replace","div","createElement","innerHTML","firstElementChild","callback","doc","copy","_destructive","adjust","tfoot","ol","children","li","index","setAttribute","display","position","boxSizing","width","paddingLeft","paddingRight","overflow","insertBefore","beforePageBreak","whenImagesAreActuallyLoaded","doPageBreak","splitElement","makePage","bind","keepTogether","offsetHeight","tag","getAttribute","tableLayout","bottomPadding","parseFloat","getPropertyValue","bottomBorder","saveAdjust","isFirst","breakAtElement","fall","fallsOnMargin","splitText","firstInParent","first","table","colgroup","thead","grid","gridHead","querySelector","repeatHeaders","range","createRange","setStartBefore","setEndBefore","extractContents","preventBulletOnListItem","padding","height","clear","pageClassName","box","available","len","selectNodeContents","nextnode","findEOP","min","max","setEnd","toString","endOffset","drawText","pushNodeInfo","renderText","_renderElement","popNodeInfo","parseBackgroundImage","tok_linear_gradient","tok_percent","tok_length","tok_keyword","tok_angle","tok_whitespace","tok_popen","tok_pclose","tok_comma","tok_url","tok_content","cache1","cache2","parse","input","hasOwnProperty","skip_ws","m","exec","substr","read","token","read_stop","color","percent","match","toRGB","read_linear_gradient","propName","angle","to1","to2","stops","reverse","parseAngle","stop","type","to","read_url","url","tok","splitProperty","map","cache","separator","cacheKey","ret","last","in_paren","in_string","looking_at","rx","trim","substring","getFontURL","getFontHeight","font","result","styleSheets","doStylesheet","ss","rules","cssRules","ex","addRules","findFonts","rule","src","cssText","styleSheet","r","family","bold","italic","addRule","names","href","name","obj","getCounter","getAllCounters","values","getPrototypeOf","incCounter","inc","resetCounter","val","doCounters","f","isNaN","updateCounters","counterReset","counterIncrement","css","toCssRgba","elements","pending","done","images","img","complete","onload","onerror","urls","bg","count","crossOrigin","alphaNumeral","n","fromCharCode","Math","floor","toLowerCase","decoration","offset","createsStackingContext","updateClipbox","path","bbox","Rect","intersect","emptyClipbox","cb","prop","pseudoElt","defa","webkit","mozilla","opera","arguments","pleaseSetPropertyValue","important","setProperty","p1","p2","toUpperCase","getBorder","side","saveStyle","func","prev","getBorderRadius","sanitizeRadius","getContentBox","innerBox","wt","wr","wb","wl","getTransform","transform","matrix","origin","radiansToDegrees","radians","PI","num","shape","setClipping","clipPath","clip","addArcToPath","points","Arc","curvePoints","curveTo","adjustBorderRadiusForBox","rTL","rTR","rBR","rBL","tl_x","tl_y","tr_x","tr_y","br_x","br_y","bl_x","bl_y","tl","tr","br","bl","elementRoundBox","bt","bb","pt","pr","pb","pl","roundBox","rTL0","rTR0","rBR0","rBL0","tmp","fill","stroke","moveTo","startAngle","endAngle","radiusX","radiusY","lineTo","close","formatCounter","evalPseudoElementContent","content","displayCounter","parseInt","getCssText","_renderWithPseudoElements","fake","pseudo","kind","place","psel","textContent","saveClass","dir","backgroundColor","backgroundImage","backgroundRepeat","backgroundPosition","backgroundOrigin","backgroundSize","textOverflow","saveTextOverflow","version","currentStyle","innerbox","boxes","cells","getClientRects","adjustBoxes","drawOneBox","g","_pdfLink","drawBullet","clipit","isFormField","maybeRenderWidget","renderContents","tableBorderLeft","tableBorderTop","tableBox","firstCell","rows","firstCellBox","drawEdge","Wtop","Wleft","Wright","rl","rr","drawRoundCorner","ri","cos","sin","anticlockwise","drawBackground","background","drawOneBackground","drawBackgroundImage","gradientRenderer","img_width","img_height","renderBG","aspect_ratio","orgBox","size","rewX","rewY","repeatX","listStyleType","listStylePosition","_drawBullet","bullet","textAlign","elementIndex","k","fontSize","lineHeight","fontFamily","idx","isLast","shouldDrawLeft","shouldDrawRight","inv","gradient","atan2","pxlen","abs","scaledAngle","atan","tan","implicit","start","end","fromRect","userSpace","console","log","visual","attr","widget","widgetInstance","exportDOMVisual","exportVisual","wrap","translate","renderImage","image","zIndexSort","b","sa","sb","za","zb","pa","getSelectedOption","selectedOptions","selectedIndex","renderCheckbox","renderFormField","option","whiteSpace","multiple","scrollLeft","scrollTop","serializeSVG","serializer","XMLSerializer","xml","serializeToString","DOMParser","parseFromString","svg","documentElement","dataURL","toDataURL","floats","positioned","floating","text","search","align","isJustified","columnCount","textTransform","estimateLineLength","prevLineBottom","underline","lineThrough","overline","underlineOffset","forEachRect","decorateUnder","doChunk","decorateOver","selectNode","clientRects","actuallyGetRangeBoundingRect","chrome","safari","rectangles","Infinity","origStart","setStart","found","findEOL","eol","startOffset","cc","code","charCodeAt","indent","l","drawTextLine","lineWidth","textBox","ypos","underlinePos","groupInStackingContext","zIndex","main","_dom_zIndex","insert","invert","transformCopy","opacity","visibility","mmul","multiplyCopy","a1","b1","c1","d1","e1","f1","a2","b2","c2","d2","e2","f2"],"sources":["C:/Users/chint/Downloads/naaviverse-frontend/node_modules/@progress/kendo-drawing/dist/es/html/core.js"],"sourcesContent":["/* eslint-disable no-multi-spaces, key-spacing, indent, camelcase, space-before-blocks, eqeqeq, brace-style */\n/* eslint-disable space-infix-ops, space-before-function-paren, array-bracket-spacing, object-curly-spacing */\n/* eslint-disable no-nested-ternary, max-params, default-case, no-else-return, no-empty, yoda */\n/* eslint-disable no-param-reassign, no-var, block-scoped-var */\n\nimport * as geo from \"../geometry\";\nimport * as PDF from \"../pdf\";\nimport { arabicToRoman, createPromise, measureText, mergeSort } from '../util';\nimport { parseColor as utils_parseColor, support, template as compileTemplate } from \"../common\";\nimport { Path, Text, Group, Image, Circle, LinearGradient } from \"../drawing\";\nimport { encodeBase64 } from \"../util\";\n\nvar browser = support.browser || {};\n/*\n\n  XXX: to test:\n\n  - cloneNodes function:\n    - drawing document containing canvas with page breaking\n    - drawing document with named radio <input>-s (should not clear selection)\n    - IE9/IE10 don't support el.dataset; do they copy user data?\n\n  - repeating table headers/footers on page breaking\n\n  - forceBreak, keepTogether\n\n  - avoidLinks\n\n */\n\n/* -----[ local vars ]----- */\n\nfunction slice(thing) {\n    return Array.prototype.slice.call(thing);\n}\n\nvar KENDO_PSEUDO_ELEMENT = \"KENDO-PSEUDO-ELEMENT\";\n\nvar IMAGE_CACHE = {};\n\nvar nodeInfo = {};\nnodeInfo._root = nodeInfo;\n\n/* -----[ Custom Text node to speed up rendering in PDF ]----- */\n\nvar inBrowser = typeof window !== 'undefined';\nvar microsoft = inBrowser ? browser.msie || browser.edge : false;\n\nvar TextRect = (function (Text) {\n  function TextRect(str, rect, options) {\n        Text.call(this, str, rect.getOrigin(), options);\n        this._pdfRect = rect;\n    }\n\n  if ( Text ) TextRect.__proto__ = Text;\n  TextRect.prototype = Object.create( Text && Text.prototype );\n  TextRect.prototype.constructor = TextRect;\n    TextRect.prototype.rect = function rect () {\n        // this is the crux of it: we can avoid a call to\n        // measure(), which is what the base class does, since we\n        // already know the rect.  measure() is s-l-o-w.\n        return this._pdfRect;\n    };\n    TextRect.prototype.rawBBox = function rawBBox () {\n        // also let's avoid creating a new rectangle.\n        return this._pdfRect;\n    };\n\n  return TextRect;\n}(Text));\n\nfunction addClass(el, cls) {\n    if (el.classList) {\n        el.classList.add(cls);\n    } else {\n        el.className += \" \" + cls;\n    }\n}\n\nfunction removeClass(el, cls) {\n    if (el.classList) {\n        el.classList.remove(cls);\n    } else {\n        el.className = el.className.split(/\\s+/).reduce(function(a, word){\n            if (word != cls) {\n                a.push(word);\n            }\n            return a;\n        }, []).join(\" \");\n    }\n}\n\nfunction setCSS(el, styles) {\n    Object.keys(styles).forEach(function(key){\n        el.style[key] = styles[key];\n    });\n}\n\nvar matches = typeof Element !== \"undefined\" && Element.prototype && (function(p){\n    if (p.matches) {\n        return function(el, selector) { return el.matches(selector); };\n    }\n    if (p.webkitMatchesSelector) {\n        return function(el, selector) { return el.webkitMatchesSelector(selector); };\n    }\n    if (p.mozMatchesSelector) {\n        return function(el, selector) { return el.mozMatchesSelector(selector); };\n    }\n    if (p.msMatchesSelector) {\n        return function(el, selector) { return el.msMatchesSelector(selector); };\n    }\n    return function(s) {\n\treturn [].indexOf.call(document.querySelectorAll(s), this) !== -1;\n    };\n})(Element.prototype);\n\nfunction closest(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    }\n    // IE: stringifying rather than simply comparing with `document`,\n    // which is not iframe-proof and fails in editor export â€”\n    // https://github.com/telerik/kendo/issues/6721\n    while (el && !/^\\[object (?:HTML)?Document\\]$/.test(String(el))) {\n        if (el.nodeType == 1 /* Element */ && matches(el, selector)) {\n            return el;\n        }\n        el = el.parentNode;\n    }\n}\n\n// clone nodes ourselves, so that we redraw <canvas> (DOM or\n// jQuery clone will not)\nvar cloneNodes = (function($){\n    if ($) {\n        // if we have Kendo and jQuery, use this version as it will\n        // maintain proper links between cloned element and Kendo\n        // widgets (i.e. it clones jQuery data(), which isn't the same\n        // as element's data attributes).\n        // https://github.com/telerik/kendo-ui-core/issues/2750\n        return function cloneNodes(el) {\n            var clone = el.cloneNode(false);\n            if (el.nodeType == 1 /* Element */) {\n                var $el = $(el), $clone = $(clone), i;\n                var data = $el.data();\n                for (i in data) {\n                    $clone.data(i, data[i]);\n                }\n                if (/^canvas$/i.test(el.tagName)) {\n                    clone.getContext(\"2d\").drawImage(el, 0, 0);\n                } else if (/^(?:input|select|textarea|option)$/i.test(el.tagName)) {\n                    // drop the name attributes so that we don't affect the selection of the\n                    // original nodes (i.e. checked status of radio buttons) when we insert our copy\n                    // into the DOM.  https://github.com/telerik/kendo/issues/5409\n                    clone.removeAttribute(\"id\");\n                    clone.removeAttribute(\"name\");\n                    if (!/^textarea$/i.test(el.tagName)) {\n                        clone.value = el.value;\n                    }\n                    clone.checked = el.checked;\n                    clone.selected = el.selected;\n                }\n                for (i = el.firstChild; i; i = i.nextSibling) {\n                    clone.appendChild(cloneNodes(i));\n                }\n            }\n            return clone;\n        };\n    } else {\n        // the no-jQuery version\n        return function cloneNodes(el) {\n            var clone = (function dive(node){\n                var clone = node.cloneNode(false);\n                if (node._kendoExportVisual) {\n                    clone._kendoExportVisual = node._kendoExportVisual;\n                }\n                for (var i = node.firstChild; i; i = i.nextSibling) {\n                    clone.appendChild(dive(i));\n                }\n                return clone;\n            })(el);\n\n            // re-draw canvases - https://github.com/telerik/kendo/issues/4872\n            var canvases = el.querySelectorAll(\"canvas\");\n            if (canvases.length) {\n                slice(clone.querySelectorAll(\"canvas\")).forEach(function (canvas, i) {\n                    canvas.getContext(\"2d\").drawImage(canvases[i], 0, 0);\n                });\n            }\n\n            // remove \"name\" attributes from <input> elements -\n            // https://github.com/telerik/kendo/issues/5409\n            var orig = el.querySelectorAll(\"input, select, textarea, option\");\n            slice(clone.querySelectorAll(\"input, select, textarea, option\")).forEach(function (el, i) {\n                el.removeAttribute(\"id\");\n                el.removeAttribute(\"name\");\n                if (!/^textarea$/i.test(el.tagName)) {\n                    el.value = orig[i].value;\n                }\n                el.checked = orig[i].checked;\n                el.selected = orig[i].selected;\n            });\n\n            return clone;\n        };\n    }\n})(typeof window !== \"undefined\" && window.kendo && window.kendo.jQuery);\n\nfunction getXY(thing) {\n    if (typeof thing == \"number\") {\n        return { x: thing, y: thing };\n    }\n    if (Array.isArray(thing)) {\n        return { x: thing[0], y: thing[1] };\n    }\n    return { x: thing.x, y: thing.y };\n}\n\nfunction drawDOM(element, options) {\n    if (!options) {\n        options = {};\n    }\n    var promise = createPromise();\n\n    if (!element) {\n        return promise.reject(\"No element to export\");\n    }\n\n    if (typeof window.getComputedStyle != \"function\") {\n        throw new Error(\"window.getComputedStyle is missing.  You are using an unsupported browser, or running in IE8 compatibility mode.  Drawing HTML is supported in Chrome, Firefox, Safari and IE9+.\");\n    }\n\n    PDF.defineFont(getFontFaces(element.ownerDocument));\n\n    var scale = getXY(options.scale || 1);\n\n    function doOne(element) {\n        var group = new Group();\n\n        // translate to start of page\n        var pos = element.getBoundingClientRect();\n        setTransform(group, [\n            scale.x,\n            0,\n            0,\n            scale.y,\n            (-pos.left * scale.x),\n            (-pos.top * scale.y)\n        ]);\n\n        nodeInfo._clipbox = false;\n        nodeInfo._matrix = geo.Matrix.unit();\n        nodeInfo._stackingContext = {\n            element: element,\n            group: group\n        };\n\n        if (options.avoidLinks === true) {\n            nodeInfo._avoidLinks = \"a\";\n        } else {\n            nodeInfo._avoidLinks = options.avoidLinks;\n        }\n\n        addClass(element, \"k-pdf-export\");\n        renderElement(element, group);\n        removeClass(element, \"k-pdf-export\");\n\n        return group;\n    }\n\n    cacheImages([ element ], function(){\n        var forceBreak = options && options.forcePageBreak;\n        var hasPaperSize = options && options.paperSize && options.paperSize != \"auto\";\n        var paperOptions = PDF.getPaperOptions(function(key, def){\n            if (key == \"paperSize\") {\n                // PDF.getPaperOptions croaks on \"auto\", just pass dummy A4 as we might\n                // still be interested in margins.\n                return hasPaperSize ? options[key] : \"A4\";\n            }\n            return key in options ? options[key] : def;\n        });\n        var pageWidth = hasPaperSize && paperOptions.paperSize[0];\n        var pageHeight = hasPaperSize && paperOptions.paperSize[1];\n        var margin = options.margin && paperOptions.margin;\n        var hasMargin = Boolean(margin);\n        if (forceBreak || pageHeight) {\n            if (!margin) {\n                margin = { left: 0, top: 0, right: 0, bottom: 0 };\n            }\n\n            // we want paper size and margin to be unaffected by\n            // scaling in the output, so we have to reverse-scale\n            // before our calculations begin.\n            if (pageWidth)  { pageWidth  /= scale.x; }\n            if (pageHeight) { pageHeight /= scale.y; }\n            margin.left   /= scale.x;\n            margin.right  /= scale.x;\n            margin.top    /= scale.y;\n            margin.bottom /= scale.y;\n\n            var group = new Group({\n                pdf: {\n                    multiPage     : true,\n                    paperSize     : hasPaperSize ? paperOptions.paperSize : \"auto\",\n                    _ignoreMargin : hasMargin // HACK!  see exportPDF in pdf/drawing.js\n                }\n            });\n            handlePageBreaks(\n                function(x) {\n                    if (options.progress) {\n                        var canceled = false, pageNum = 0;\n                        (function next(){\n                            if (pageNum < x.pages.length) {\n                                var page = doOne(x.pages[pageNum]);\n                                group.append(page);\n                                options.progress({\n                                    page: page,\n                                    pageNum: ++pageNum,\n                                    totalPages: x.pages.length,\n                                    cancel: function() {\n                                        canceled = true;\n                                    }\n                                });\n                                if (!canceled) {\n                                    setTimeout(next);\n                                } else {\n                                    // XXX: should we also fail() the deferred object?\n                                    x.container.parentNode.removeChild(x.container);\n                                }\n                            } else {\n                                x.container.parentNode.removeChild(x.container);\n                                promise.resolve(group);\n                            }\n                        })();\n                    } else {\n                        x.pages.forEach(function(page){\n                            group.append(doOne(page));\n                        });\n                        x.container.parentNode.removeChild(x.container);\n                        promise.resolve(group);\n                    }\n                },\n                element,\n                forceBreak,\n                pageWidth ? pageWidth - margin.left - margin.right : null,\n                pageHeight ? pageHeight - margin.top - margin.bottom : null,\n                margin,\n                options\n            );\n        } else {\n            promise.resolve(doOne(element));\n        }\n    });\n\n    function makeTemplate(template) {\n        if (template != null) {\n            if (typeof template == \"string\") {\n                template = compileTemplate(template.replace(/^\\s+|\\s+$/g, \"\"));\n            }\n            if (typeof template == \"function\") {\n                return function(data) {\n                    var el = template(data);\n                    if (el && typeof el == \"string\") {\n                        var div = document.createElement(\"div\");\n                        div.innerHTML = el;\n                        el = div.firstElementChild;\n                    }\n                    return el;\n                };\n            }\n            // assumed DOM element\n            return function() {\n                return template.cloneNode(true);\n            };\n        }\n    }\n\n    function handlePageBreaks(callback, element, forceBreak, pageWidth, pageHeight, margin, options) {\n        var template = makeTemplate(options.template);\n        var doc = element.ownerDocument;\n        var pages = [];\n        var copy = options._destructive ? element : cloneNodes(element);\n        var container = doc.createElement(\"KENDO-PDF-DOCUMENT\");\n        var adjust = 0;\n\n        // make sure <tfoot> elements are at the end (Grid widget\n        // places TFOOT before TBODY, tricking our algorithm to\n        // insert a page break right after the header).\n        // https://github.com/telerik/kendo/issues/4699\n        slice(copy.querySelectorAll(\"tfoot\")).forEach(function(tfoot){\n            tfoot.parentNode.appendChild(tfoot);\n        });\n\n        // remember the index of each LI from an ordered list.\n        // we'll use it to reconstruct the proper numbering.\n        slice(copy.querySelectorAll(\"ol\")).forEach(function(ol){\n            slice(ol.children).forEach(function(li, index){\n                li.setAttribute(\"kendo-split-index\", index);\n            });\n        });\n\n        setCSS(container, {\n            display   : \"block\",\n            position  : \"absolute\",\n            boxSizing : \"content-box\",\n            left      : \"-10000px\",\n            top       : \"-10000px\"\n        });\n\n        if (pageWidth) {\n            // subtle: if we don't set the width *and* margins here, the layout in this\n            // container will be different from the one in our final page elements, and we'll\n            // split at the wrong places.\n            setCSS(container, {\n                width        : pageWidth + \"px\",\n                paddingLeft  : margin.left + \"px\",\n                paddingRight : margin.right + \"px\"\n            });\n\n            // when the first element has a margin-top (i.e. a <h1>) the page will be\n            // inadvertently enlarged by that number (the browser will report the container's\n            // bounding box top to start at the element's top, rather than including its\n            // margin).  Adding overflow: hidden seems to fix it.\n            //\n            // to understand the difference, try the following snippets in your browser:\n            //\n            // 1. <div style=\"background: yellow\">\n            //      <h1 style=\"margin: 3em\">Foo</h1>\n            //    </div>\n            //\n            // 2. <div style=\"background: yellow; overflow: hidden\">\n            //      <h1 style=\"margin: 3em\">Foo</h1>\n            //    </div>\n            //\n            // this detail is not important when automatic page breaking is not requested, hence\n            // doing it only if pageWidth is defined.\n            setCSS(copy, { overflow: \"hidden\" });\n        }\n\n        element.parentNode.insertBefore(container, element);\n        container.appendChild(copy);\n\n        // With cache disabled, images will still have height zero until their `complete` attribute\n        // is true.  `whenImagesAreActuallyLoaded` will wait for it.\n        if (options.beforePageBreak) {\n            whenImagesAreActuallyLoaded([ container ], function() {\n                options.beforePageBreak(container, doPageBreak);\n            });\n        } else {\n            whenImagesAreActuallyLoaded([ container ], doPageBreak);\n        }\n\n        function doPageBreak() {\n            if (forceBreak != \"-\" || pageHeight) {\n                splitElement(copy);\n            }\n\n            {\n                var page = makePage();\n                copy.parentNode.insertBefore(page, copy);\n                page.appendChild(copy);\n            }\n\n            if (template) {\n                pages.forEach(function(page, i){\n                    var el = template({\n                        element    : page,\n                        pageNum    : i + 1,\n                        totalPages : pages.length\n                    });\n                    if (el) {\n                        page.appendChild(el);\n                    }\n                });\n            }\n\n            cacheImages(pages, callback.bind(null, { pages: pages, container: container }));\n        }\n\n        function keepTogether(el) {\n            if (options.keepTogether && matches(el, options.keepTogether) && el.offsetHeight <= pageHeight - adjust) {\n                return true;\n            }\n\n            var tag = el.tagName;\n            if (/^h[1-6]$/i.test(tag) && el.offsetHeight >= pageHeight - adjust) {\n                return false;\n            }\n\n            return (el.getAttribute(\"data-kendo-chart\") ||\n                    /^(?:img|tr|thead|th|tfoot|iframe|svg|object|canvas|input|textarea|select|video|h[1-6])/i.test(el.tagName));\n        }\n\n        function splitElement(element) {\n            if (element.tagName == \"TABLE\") {\n                setCSS(element, { tableLayout: \"fixed\" });\n            }\n            if (keepTogether(element)) {\n                return;\n            }\n            var style = getComputedStyle(element);\n            var bottomPadding = parseFloat(getPropertyValue(style, \"padding-bottom\"));\n            var bottomBorder = parseFloat(getPropertyValue(style, \"border-bottom-width\"));\n            var saveAdjust = adjust;\n            adjust += bottomPadding + bottomBorder;\n            var isFirst = true;\n            for (var el = element.firstChild; el; el = el.nextSibling) {\n                if (el.nodeType == 1 /* Element */) {\n                    isFirst = false;\n                    if (matches(el, forceBreak)) {\n                        breakAtElement(el);\n                        continue;\n                    }\n                    if (!pageHeight) {\n                        // we're in \"manual breaks mode\"\n                        splitElement(el);\n                        continue;\n                    }\n                    if (!/^(?:static|relative)$/.test(getPropertyValue(getComputedStyle(el), \"position\"))) {\n                        continue;\n                    }\n                    var fall = fallsOnMargin(el);\n                    if (fall == 1) {\n                        // element starts on next page, break before anyway.\n                        breakAtElement(el);\n                    }\n                    else if (fall) {\n                        // elements ends up on next page, or possibly doesn't fit on a page at\n                        // all.  break before it anyway if it's an <img> or <tr>, otherwise\n                        // attempt to split.\n                        if (keepTogether(el)) {\n                            breakAtElement(el);\n                        } else {\n                            splitElement(el);\n                        }\n                    }\n                    else {\n                        splitElement(el);\n                    }\n                }\n                else if (el.nodeType == 3 /* Text */ && pageHeight) {\n                    splitText(el, isFirst);\n                    isFirst = false;\n                }\n            }\n            adjust = saveAdjust;\n        }\n\n        function firstInParent(el) {\n            var p = el.parentNode, first = p.firstChild;\n            if (el === first) {\n                return true;\n            }\n            if (el === p.children[0]) {\n                if (first.nodeType == 7 /* comment */ ||\n                    first.nodeType == 8 /* processing instruction */) {\n                    return true;\n                }\n                if (first.nodeType == 3 /* text */) {\n                    // if whitespace only we can probably consider it's first\n                    return !/\\S/.test(first.data);\n                }\n            }\n            return false;\n        }\n\n        function breakAtElement(el) {\n            if (el.nodeType == 1 && el !== copy && firstInParent(el)) {\n                return breakAtElement(el.parentNode);\n            }\n            var table, colgroup, thead, grid, gridHead;\n            table = closest(el, \"table\");\n            colgroup = table && table.querySelector(\"colgroup\");\n            if (options.repeatHeaders) {\n                thead = table && table.querySelector(\"thead\");\n\n                // If we break page in a Kendo Grid, repeat its header.  This ugly hack is\n                // necessary because a scrollable grid will keep the header in a separate\n                // <table> element from its content.\n                //\n                // XXX: This is likely to break as soon as the widget HTML is modified.\n                grid = closest(el, \".k-grid.k-widget\");\n                if (grid && grid.querySelector(\".k-auto-scrollable\")) {\n                    gridHead = grid.querySelector(\".k-grid-header\");\n                }\n            }\n            var page = makePage();\n            var range = doc.createRange();\n            range.setStartBefore(copy);\n            range.setEndBefore(el);\n            page.appendChild(range.extractContents());\n            copy.parentNode.insertBefore(page, copy);\n            preventBulletOnListItem(el.parentNode);\n            if (table) {\n                table = closest(el, \"table\"); // that's the <table> on next page!\n                if (options.repeatHeaders && thead) {\n                    table.insertBefore(thead.cloneNode(true), table.firstChild);\n                }\n                if (colgroup) {\n                    table.insertBefore(colgroup.cloneNode(true), table.firstChild);\n                }\n            }\n            if (options.repeatHeaders && gridHead) {\n                grid = closest(el, \".k-grid.k-widget\");\n                grid.insertBefore(gridHead.cloneNode(true), grid.firstChild);\n            }\n        }\n\n        function makePage() {\n            var page = doc.createElement(\"KENDO-PDF-PAGE\");\n            setCSS(page, {\n                display  : \"block\",\n                boxSizing: \"content-box\",\n                width    : pageWidth ? (pageWidth + \"px\") : \"auto\",\n                padding  : (margin.top + \"px \" +\n                            margin.right + \"px \" +\n                            margin.bottom + \"px \" +\n                            margin.left + \"px\"),\n\n                // allow absolutely positioned elements to be relative to current page\n                position : \"relative\",\n\n                // without the following we might affect layout of subsequent pages\n                height   : pageHeight ? (pageHeight + \"px\") : \"auto\",\n                overflow : pageHeight || pageWidth ? \"hidden\" : \"visible\",\n                clear    : \"both\"\n            });\n\n            // debug\n            // $(\"<div>\").css({\n            //     position  : \"absolute\",\n            //     left      : margin.left,\n            //     top       : margin.top,\n            //     width     : pageWidth,\n            //     height    : pageHeight,\n            //     boxSizing : \"border-box\",\n            //     background: \"rgba(255, 255, 0, 0.5)\"\n            //     //border    : \"1px solid red\"\n            // }).appendTo(page);\n\n            if (options && options.pageClassName) {\n                page.className = options.pageClassName;\n            }\n            pages.push(page);\n            return page;\n        }\n\n        function fallsOnMargin(thing) {\n            var box = thing.getBoundingClientRect();\n            if (box.width === 0 || box.height === 0) {\n                // I'd say an element with dimensions zero fits on current page.\n                return 0;\n            }\n            var top = copy.getBoundingClientRect().top;\n            var available = pageHeight - adjust;\n            return (box.height > available) ? 3\n                : (box.top - top > available) ? 1\n                : (box.bottom - top > available) ? 2\n                : 0;\n        }\n\n        function splitText(node, isFirst) {\n            if (!/\\S/.test(node.data)) {\n                return;\n            }\n\n            var len = node.data.length;\n            var range = doc.createRange();\n            range.selectNodeContents(node);\n            var fall = fallsOnMargin(range);\n            if (!fall) {\n                return;     // the whole text fits on current page\n            }\n\n            var nextnode = node;\n            if (fall == 1) {\n                // starts on next page, break before anyway.\n                if (isFirst) {\n                    // avoid leaving an empty <p>, <li>, etc. on previous page.\n                    breakAtElement(node.parentNode);\n                } else {\n                    breakAtElement(node);\n                }\n            }\n            else {\n                (function findEOP(min, pos, max) {\n                    range.setEnd(node, pos);\n                    if (min == pos || pos == max) {\n                        return pos;\n                    }\n                    if (fallsOnMargin(range)) {\n                        return findEOP(min, (min + pos) >> 1, pos);\n                    } else {\n                        return findEOP(pos, (pos + max) >> 1, max);\n                    }\n                })(0, len >> 1, len);\n\n                if (!/\\S/.test(range.toString()) && isFirst) {\n                    // avoid leaving an empty <p>, <li>, etc. on previous page.\n                    breakAtElement(node.parentNode);\n                } else {\n                    // This is only needed for IE, but it feels cleaner to do it anyway.  Without\n                    // it, IE will truncate a very long text (playground/pdf-long-text-2.html).\n                    nextnode = node.splitText(range.endOffset);\n\n                    var page = makePage();\n                    range.setStartBefore(copy);\n                    page.appendChild(range.extractContents());\n                    copy.parentNode.insertBefore(page, copy);\n                    preventBulletOnListItem(nextnode.parentNode);\n                }\n            }\n\n            splitText(nextnode);\n        }\n\n        function preventBulletOnListItem(el) {\n            // set a hint on continued LI elements, to tell the\n            // renderer not to draw the bullet again.\n            // https://github.com/telerik/kendo-ui-core/issues/2732\n            var li = closest(el, \"li\");\n            if (li) {\n                li.setAttribute(\"kendo-no-bullet\", \"1\");\n                preventBulletOnListItem(li.parentNode);\n            }\n        }\n    }\n\n    return promise;\n}\n\n// This is needed for the Spreadsheet print functionality.  Since\n// there we only need to draw text, this cuts through the ceremony\n// of drawDOM/renderElement and renders the text node directly.\nfunction drawText(element) {\n    var group = new Group();\n    nodeInfo._clipbox = false;\n    nodeInfo._matrix = geo.Matrix.unit();\n    nodeInfo._stackingContext = {\n        element: element,\n        group: group\n    };\n    pushNodeInfo(element, getComputedStyle(element), group);\n    if (element.firstChild.nodeType == 3 /* Text */) {\n        // avoid the penalty of renderElement\n        renderText(element, element.firstChild, group);\n    } else {\n        _renderElement(element, group);\n    }\n    popNodeInfo();\n    return group;\n}\n\nvar parseBackgroundImage = (function(){\n    var tok_linear_gradient  = /^((-webkit-|-moz-|-o-|-ms-)?linear-gradient\\s*)\\(/;\n    //var tok_radial_gradient  = /^((-webkit-|-moz-|-o-|-ms-)?radial-gradient\\s*)\\(/;\n    var tok_percent          = /^([-0-9.]+%)/;\n    var tok_length           = /^([-0-9.]+px)/;\n    var tok_keyword          = /^(left|right|top|bottom|to|center)\\W/;\n    var tok_angle            = /^([-0-9.]+(deg|grad|rad|turn)|0)/;\n    var tok_whitespace       = /^(\\s+)/;\n    var tok_popen            = /^(\\()/;\n    var tok_pclose           = /^(\\))/;\n    var tok_comma            = /^(,)/;\n    var tok_url              = /^(url)\\(/;\n    var tok_content          = /^(.*?)\\)/;\n\n    var cache1 = {}, cache2 = {};\n\n    function parse(input) {\n        var orig = input;\n        if (hasOwnProperty(cache1, orig)) {\n            return cache1[orig];\n        }\n        function skip_ws() {\n            var m = tok_whitespace.exec(input);\n            if (m) {\n                input = input.substr(m[1].length);\n            }\n        }\n        function read(token) {\n            skip_ws();\n            var m = token.exec(input);\n            if (m) {\n                input = input.substr(m[1].length);\n                return m[1];\n            }\n        }\n\n        function read_stop() {\n            var color = utils_parseColor(input, true);\n            var length, percent;\n            if (color) {\n                var match =\n                    /^#[0-9a-f]+/i.exec(input) ||\n                    /^rgba?\\(.*?\\)/i.exec(input) ||\n                    /^..*?\\b/.exec(input); // maybe named color\n                input = input.substr(match[0].length);\n                color = color.toRGB();\n                if (!(length = read(tok_length))) {\n                    percent = read(tok_percent);\n                }\n                return { color: color, length: length, percent: percent };\n            }\n        }\n\n        function read_linear_gradient(propName) {\n            var angle;\n            var to1, to2;\n            var stops = [];\n            var reverse = false;\n\n            if (read(tok_popen)) {\n                // 1. [ <angle> || to <side-or-corner>, ]?\n                angle = read(tok_angle);\n                if (angle == \"0\") {\n                    angle = \"0deg\"; // Edge\n                }\n                if (angle) {\n                    angle = parseAngle(angle);\n                    read(tok_comma);\n                }\n                else {\n                    to1 = read(tok_keyword);\n                    if (to1 == \"to\") {\n                        to1 = read(tok_keyword);\n                    } else if (to1 && /^-/.test(propName)) {\n                        reverse = true;\n                    }\n                    to2 = read(tok_keyword);\n                    read(tok_comma);\n                }\n\n                if (/-moz-/.test(propName) && angle == null && to1 == null) {\n                    var x = read(tok_percent), y = read(tok_percent);\n                    reverse = true;\n                    if (x == \"0%\") {\n                        to1 = \"left\";\n                    } else if (x == \"100%\") {\n                        to1 = \"right\";\n                    }\n                    if (y == \"0%\") {\n                        to2 = \"top\";\n                    } else if (y == \"100%\") {\n                        to2 = \"bottom\";\n                    }\n                    read(tok_comma);\n                }\n\n                // 2. color stops\n                while (input && !read(tok_pclose)) {\n                    var stop = read_stop();\n                    if (!stop) {\n                        break;\n                    }\n                    stops.push(stop);\n                    read(tok_comma);\n                }\n\n                return {\n                    type    : \"linear\",\n                    angle   : angle,\n                    to      : to1 && to2 ? to1 + \" \" + to2 : to1 ? to1 : to2 ? to2 : null,\n                    stops   : stops,\n                    reverse : reverse\n                };\n            }\n        }\n\n        function read_url() {\n            if (read(tok_popen)) {\n                var url = read(tok_content);\n                url = url.replace(/^['\"]+|[\"']+$/g, \"\");\n                read(tok_pclose);\n                return { type: \"url\", url: url };\n            }\n        }\n\n        var tok;\n\n        if ((tok = read(tok_linear_gradient))) {\n            tok = read_linear_gradient(tok);\n        }\n        else if ((tok = read(tok_url))) {\n            tok = read_url();\n        }\n\n        return (cache1[orig] = tok || { type: \"none\" });\n    }\n\n    return function(input) {\n        if (hasOwnProperty(cache2, input)) {\n            return cache2[input];\n        }\n        return (cache2[input] = splitProperty(input).map(parse));\n    };\n})();\n\nvar splitProperty = (function(){\n    var cache = {};\n    return function(input, separator) {\n        if (!separator) {\n            separator = /^\\s*,\\s*/;\n        }\n\n        var cacheKey = input + separator;\n\n        if (hasOwnProperty(cache, cacheKey)) {\n            return cache[cacheKey];\n        }\n\n        var ret = [];\n        var last = 0, pos = 0;\n        var in_paren = 0;\n        var in_string = false;\n        var m;\n\n        function looking_at(rx) {\n            return (m = rx.exec(input.substr(pos)));\n        }\n\n        function trim(str) {\n            return str.replace(/^\\s+|\\s+$/g, \"\");\n        }\n\n        while (pos < input.length) {\n            if (!in_string && looking_at(/^[\\(\\[\\{]/)) {\n                in_paren++;\n                pos++;\n            }\n            else if (!in_string && looking_at(/^[\\)\\]\\}]/)) {\n                in_paren--;\n                pos++;\n            }\n            else if (!in_string && looking_at(/^[\\\"\\']/)) {\n                in_string = m[0];\n                pos++;\n            }\n            else if (in_string == \"'\" && looking_at(/^\\\\\\'/)) {\n                pos += 2;\n            }\n            else if (in_string == '\"' && looking_at(/^\\\\\\\"/)) {\n                pos += 2;\n            }\n            else if (in_string == \"'\" && looking_at(/^\\'/)) {\n                in_string = false;\n                pos++;\n            }\n            else if (in_string == '\"' && looking_at(/^\\\"/)) {\n                in_string = false;\n                pos++;\n            }\n            else if (looking_at(separator)) {\n                if (!in_string && !in_paren && pos > last) {\n                    ret.push(trim(input.substring(last, pos)));\n                    last = pos + m[0].length;\n                }\n                pos += m[0].length;\n            }\n            else {\n                pos++;\n            }\n        }\n        if (last < pos) {\n            ret.push(trim(input.substring(last, pos)));\n        }\n        return (cache[cacheKey] = ret);\n    };\n})();\n\nvar getFontURL = (function(cache){\n    return function(el){\n        // XXX: for IE we get here the whole cssText of the rule,\n        // because the computedStyle.src is empty.  Next time we need\n        // to fix these regexps we better write a CSS parser. :-\\\n        var url = cache[el];\n        if (!url) {\n            var m;\n            if ((m = /url\\((['\"]?)([^'\")]*?)\\1\\)\\s+format\\((['\"]?)truetype\\3\\)/.exec(el))) {\n                url = cache[el] = m[2];\n            } else if ((m = /url\\((['\"]?)([^'\")]*?\\.ttf)\\1\\)/.exec(el))) {\n                url = cache[el] = m[2];\n            }\n        }\n        return url;\n    };\n})(Object.create(null));\n\nvar getFontHeight = (function(cache){\n    return function(font) {\n        var height = cache[font];\n        if (height == null) {\n            height = cache[font] = measureText(\"Mapq\", { font: font }).height;\n        }\n        return height;\n    };\n})(Object.create(null));\n\nfunction getFontFaces(doc) {\n    if (doc == null) {\n        doc = document;\n    }\n    var result = {};\n    for (var i = 0; i < doc.styleSheets.length; ++i) {\n        doStylesheet(doc.styleSheets[i]);\n    }\n    return result;\n    function doStylesheet(ss) {\n        if (ss) {\n            var rules = null;\n            try {\n                rules = ss.cssRules;\n            } catch (ex) {}\n            if (rules) {\n                addRules(ss, rules);\n            }\n        }\n    }\n    function findFonts(rule) {\n        var src = getPropertyValue(rule.style, \"src\");\n        if (src) {\n            return splitProperty(src).reduce(function(a, el){\n                var font = getFontURL(el);\n                if (font) {\n                    a.push(font);\n                }\n                return a;\n            }, []);\n        } else {\n            // Internet Explorer\n            // XXX: this is gross.  should work though for valid CSS.\n            var font = getFontURL(rule.cssText);\n            return font ? [ font ] : [];\n        }\n    }\n    function addRules(styleSheet, rules) {\n        for (var i = 0; i < rules.length; ++i) {\n            var r = rules[i];\n            switch (r.type) {\n              case 3:       // CSSImportRule\n                doStylesheet(r.styleSheet);\n                break;\n              case 5:       // CSSFontFaceRule\n                var style  = r.style;\n                var family = splitProperty(getPropertyValue(style, \"font-family\"));\n                var bold   = /^([56789]00|bold)$/i.test(getPropertyValue(style, \"font-weight\"));\n                var italic = \"italic\" == getPropertyValue(style, \"font-style\");\n                var src    = findFonts(r);\n                if (src.length > 0) {\n                    addRule(styleSheet, family, bold, italic, src[0]);\n                }\n            }\n        }\n    }\n    function addRule(styleSheet, names, bold, italic, url) {\n        // We get full resolved absolute URLs in Chrome, but sadly\n        // not in Firefox.\n        if (!(/^data:/i.test(url))) {\n            if (!(/^[^\\/:]+:\\/\\//.test(url) || /^\\//.test(url))) {\n                url = String(styleSheet.href).replace(/[^\\/]*$/, \"\") + url;\n            }\n        }\n        names.forEach(function(name){\n            name = name.replace(/^(['\"]?)(.*?)\\1$/, \"$2\"); // it's quoted\n            if (bold) {\n                name += \"|bold\";\n            }\n            if (italic) {\n                name += \"|italic\";\n            }\n            result[name] = url;\n        });\n    }\n}\n\nfunction hasOwnProperty(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction getCounter(name) {\n    name = \"_counter_\" + name;\n    return nodeInfo[name];\n}\n\nfunction getAllCounters(name) {\n    var values = [], p = nodeInfo;\n    name = \"_counter_\" + name;\n    while (p) {\n        if (hasOwnProperty(p, name)) {\n            values.push(p[name]);\n        }\n        p = Object.getPrototypeOf(p);\n    }\n    return values.reverse();\n}\n\nfunction incCounter(name, inc) {\n    var p = nodeInfo;\n    name = \"_counter_\" + name;\n    while (p && !hasOwnProperty(p, name)) {\n        p = Object.getPrototypeOf(p);\n    }\n    if (!p) {\n        p = nodeInfo._root;\n    }\n    p[name] = (p[name] || 0) + (inc == null ? 1 : inc);\n}\n\nfunction resetCounter(name, val) {\n    name = \"_counter_\" + name;\n    nodeInfo[name] = val == null ? 0 : val;\n}\n\nfunction doCounters(a, f, def) {\n    for (var i = 0; i < a.length;) {\n        var name = a[i++];\n        var val = parseFloat(a[i]);\n        if (isNaN(val)) {\n            f(name, def);\n        } else {\n            f(name, val);\n            ++i;\n        }\n    }\n}\n\nfunction updateCounters(style) {\n    var counterReset = getPropertyValue(style, \"counter-reset\");\n    if (counterReset) {\n        doCounters(splitProperty(counterReset, /^\\s+/), resetCounter, 0);\n    }\n    var counterIncrement = getPropertyValue(style, \"counter-increment\");\n    if (counterIncrement) {\n        doCounters(splitProperty(counterIncrement, /^\\s+/), incCounter, 1);\n    }\n}\n\nfunction parseColor(str, css) {\n    var color = utils_parseColor(str, true);\n    if (color) {\n        color = color.toRGB();\n        if (css) {\n            color = color.toCssRgba();\n        } else if (color.a === 0) {\n            color = null;\n        }\n    }\n    return color;\n}\n\nfunction whenImagesAreActuallyLoaded(elements, callback) {\n    var pending = 0;\n    var done = false;\n    elements.forEach(function(el){\n        var images = el.querySelectorAll(\"img\");\n        for (var i = 0; i < images.length; ++i) {\n            var img = images[i];\n            if (!img.complete) {\n                pending++;\n                img.onload = img.onerror = next;\n            }\n        }\n    });\n\n    if (!pending) {\n        next();\n    }\n\n    function next() {\n        if (!done && --pending <= 0) {\n            callback();\n            done = true;\n        }\n    }\n}\n\nfunction cacheImages(elements, callback) {\n    var urls = [];\n    function add(url) {\n        if (!IMAGE_CACHE[url]) {\n            IMAGE_CACHE[url] = true;\n            urls.push(url);\n        }\n    }\n\n    elements.forEach(function dive(element){\n        if (/^img$/i.test(element.tagName)) {\n            add(element.src);\n        }\n        parseBackgroundImage(\n            getPropertyValue(\n                getComputedStyle(element), \"background-image\"\n            )\n        ).forEach(function(bg){\n            if (bg.type == \"url\") {\n                add(bg.url);\n            }\n        });\n\n        if (element.children) {\n            slice(element.children).forEach(dive);\n        }\n    });\n\n    var count = urls.length;\n    function next() {\n        if (--count <= 0) {\n            // Even though we cached them, they simply won't be available immediately in the newly\n            // created DOM.  Previously we'd allow a 10ms timeout, but that's arbitrary and clearly\n            // not working in all cases (https://github.com/telerik/kendo/issues/5399), so this\n            // function will wait for their .complete attribute.\n            whenImagesAreActuallyLoaded(elements, callback);\n        }\n    }\n    if (count === 0) {\n        next();\n    }\n    urls.forEach(function(url){\n        var img = IMAGE_CACHE[url] = new window.Image();\n        if (!(/^data:/i.test(url))) {\n            img.crossOrigin = \"Anonymous\";\n        }\n        img.src = url;\n        if (img.complete) {\n            next();\n        } else {\n            img.onload = next;\n            img.onerror = function() {\n                IMAGE_CACHE[url] = null;\n                next();\n            };\n        }\n    });\n}\n\nfunction alphaNumeral(n) {\n    var result = \"\";\n    do {\n        var r = n % 26;\n        result = String.fromCharCode(97 + r) + result;\n        n = Math.floor(n / 26);\n    } while (n > 0);\n    return result;\n}\n\nfunction pushNodeInfo(element, style, group) {\n    nodeInfo = Object.create(nodeInfo);\n    nodeInfo[element.tagName.toLowerCase()] = {\n        element: element,\n        style: style\n    };\n    var decoration = getPropertyValue(style, \"text-decoration\");\n    if (decoration && decoration != \"none\") {\n        var color = getPropertyValue(style, \"text-decoration-color\");\n        decoration.split(/\\s+/g).forEach(function(name){\n            if (!nodeInfo[name]) {\n                nodeInfo[name] = color;\n                if (name == \"underline\") {\n                    var offset = getPropertyValue(style, \"text-underline-offset\");\n                    if (offset != \"auto\") {\n                        nodeInfo[\"underline-offset\"] = parseFloat(offset);\n                    }\n                }\n            }\n        });\n    }\n\n    if (createsStackingContext(style)) {\n        nodeInfo._stackingContext = {\n            element: element,\n            group: group\n        };\n    }\n}\n\nfunction popNodeInfo() {\n    nodeInfo = Object.getPrototypeOf(nodeInfo);\n}\n\nfunction updateClipbox(path) {\n    if (nodeInfo._clipbox != null) {\n        var box = path.bbox(nodeInfo._matrix);\n        if (nodeInfo._clipbox) {\n            nodeInfo._clipbox = geo.Rect.intersect(nodeInfo._clipbox, box);\n        } else {\n            nodeInfo._clipbox = box;\n        }\n    }\n}\n\nfunction emptyClipbox() {\n    var cb = nodeInfo._clipbox;\n    if (cb == null) {\n        return true;\n    }\n    if (cb) {\n        return cb.width() === 0 || cb.height() === 0;\n    }\n}\n\nfunction createsStackingContext(style) {\n    function prop(name) { return getPropertyValue(style, name); }\n    if (prop(\"transform\") != \"none\" ||\n        prop(\"position\") != \"static\" ||\n        prop(\"z-index\") != \"auto\" ||\n        prop(\"opacity\") < 1) {\n        return true;\n    }\n}\n\nfunction getComputedStyle(element, pseudoElt) {\n    return window.getComputedStyle(element, pseudoElt || null);\n}\n\nfunction getPropertyValue(style, prop, defa) {\n    var val = style.getPropertyValue(prop);\n    if (val == null || val === \"\") {\n        if (browser.webkit) {\n            val = style.getPropertyValue(\"-webkit-\" + prop );\n        } else if (browser.mozilla) {\n            val = style.getPropertyValue(\"-moz-\" + prop );\n        } else if (browser.opera) {\n            val = style.getPropertyValue(\"-o-\" + prop);\n        } else if (microsoft) {\n            val = style.getPropertyValue(\"-ms-\" + prop);\n        }\n    }\n    if (arguments.length > 2 && (val == null || val === \"\")) {\n        return defa;\n    } else {\n        return val;\n    }\n}\n\nfunction pleaseSetPropertyValue(style, prop, value, important) {\n    style.setProperty(prop, value, important);\n    if (browser.webkit) {\n        style.setProperty(\"-webkit-\" + prop, value, important);\n    } else if (browser.mozilla) {\n        style.setProperty(\"-moz-\" + prop, value, important);\n    } else if (browser.opera) {\n        style.setProperty(\"-o-\" + prop, value, important);\n    } else if (microsoft) {\n        style.setProperty(\"-ms-\" + prop, value, important);\n        prop = \"ms\" + prop.replace(/(^|-)([a-z])/g, function(s, p1, p2){\n            return p1 + p2.toUpperCase();\n        });\n        style[prop] = value;\n    }\n}\n\nfunction getBorder(style, side) {\n    side = \"border-\" + side;\n    return {\n        width: parseFloat(getPropertyValue(style, side + \"-width\")),\n        style: getPropertyValue(style, side + \"-style\"),\n        color: parseColor(getPropertyValue(style, side + \"-color\"), true)\n    };\n}\n\nfunction saveStyle(element, func) {\n    var prev = element.style.cssText;\n    var result = func();\n    element.style.cssText = prev;\n    return result;\n}\n\nfunction getBorderRadius(style, side) {\n    var r = getPropertyValue(style, \"border-\" + side + \"-radius\").split(/\\s+/g).map(parseFloat);\n    if (r.length == 1) {\n        r.push(r[0]);\n    }\n    return sanitizeRadius({ x: r[0], y: r[1] });\n}\n\nfunction getContentBox(element) {\n    var box = element.getBoundingClientRect();\n    box = innerBox(box, \"border-*-width\", element);\n    box = innerBox(box, \"padding-*\", element);\n    return box;\n}\n\nfunction innerBox(box, prop, element) {\n    var style, wt, wr, wb, wl;\n    if (typeof prop == \"string\") {\n        style = getComputedStyle(element);\n        wt = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"top\")));\n        wr = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"right\")));\n        wb = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"bottom\")));\n        wl = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"left\")));\n    }\n    else if (typeof prop == \"number\") {\n        wt = wr = wb = wl = prop;\n    }\n    return {\n        top    : box.top + wt,\n        right  : box.right - wr,\n        bottom : box.bottom - wb,\n        left   : box.left + wl,\n        width  : box.right - box.left - wr - wl,\n        height : box.bottom - box.top - wb - wt\n    };\n}\n\nfunction getTransform(style) {\n    var transform = getPropertyValue(style, \"transform\");\n    if (transform == \"none\") {\n        return null;\n    }\n    var matrix = /^\\s*matrix\\(\\s*(.*?)\\s*\\)\\s*$/.exec(transform);\n    if (matrix) {\n        var origin = getPropertyValue(style, \"transform-origin\");\n        matrix = matrix[1].split(/\\s*,\\s*/g).map(parseFloat);\n        origin = origin.split(/\\s+/g).map(parseFloat);\n        return {\n            matrix: matrix,\n            origin: origin\n        };\n    }\n}\n\nfunction radiansToDegrees(radians) {\n    return ((180 * radians) / Math.PI) % 360;\n}\n\nfunction parseAngle(angle) {\n    var num = parseFloat(angle);\n    if (/grad$/.test(angle)) {\n        return Math.PI * num / 200;\n    }\n    else if (/rad$/.test(angle)) {\n        return num;\n    }\n    else if (/turn$/.test(angle)) {\n        return Math.PI * num * 2;\n    }\n    else if (/deg$/.test(angle)) {\n        return Math.PI * num / 180;\n    }\n}\n\nfunction setTransform(shape, m) {\n    m = new geo.Matrix(m[0], m[1], m[2], m[3], m[4], m[5]);\n    shape.transform(m);\n    return m;\n}\n\nfunction setClipping(shape, clipPath) {\n    shape.clip(clipPath);\n}\n\nfunction addArcToPath(path, x, y, options) {\n    var points = new geo.Arc([ x, y ], options).curvePoints(), i = 1;\n    while (i < points.length) {\n        path.curveTo(points[i++], points[i++], points[i++]);\n    }\n}\n\nfunction sanitizeRadius(r) {\n    if (r.x <= 0 || r.y <= 0) {\n        r.x = r.y = 0;\n    }\n    return r;\n}\n\nfunction adjustBorderRadiusForBox(box, rTL, rTR, rBR, rBL) {\n    // adjust border radiuses such that the sum of adjacent\n    // radiuses is not bigger than the length of the side.\n    // seems the correct algorithm is variant (3) from here:\n    // http://www.w3.org/Style/CSS/Tracker/issues/29?changelog\n    var tl_x = Math.max(0, rTL.x), tl_y = Math.max(0, rTL.y);\n    var tr_x = Math.max(0, rTR.x), tr_y = Math.max(0, rTR.y);\n    var br_x = Math.max(0, rBR.x), br_y = Math.max(0, rBR.y);\n    var bl_x = Math.max(0, rBL.x), bl_y = Math.max(0, rBL.y);\n\n    var f = Math.min(\n        box.width / (tl_x + tr_x),\n        box.height / (tr_y + br_y),\n        box.width / (br_x + bl_x),\n        box.height / (bl_y + tl_y)\n    );\n\n    if (f < 1) {\n        tl_x *= f; tl_y *= f;\n        tr_x *= f; tr_y *= f;\n        br_x *= f; br_y *= f;\n        bl_x *= f; bl_y *= f;\n    }\n\n    return {\n        tl: { x: tl_x, y: tl_y },\n        tr: { x: tr_x, y: tr_y },\n        br: { x: br_x, y: br_y },\n        bl: { x: bl_x, y: bl_y }\n    };\n}\n\nfunction elementRoundBox(element, box, type) {\n    var style = getComputedStyle(element);\n\n    var rTL = getBorderRadius(style, \"top-left\");\n    var rTR = getBorderRadius(style, \"top-right\");\n    var rBL = getBorderRadius(style, \"bottom-left\");\n    var rBR = getBorderRadius(style, \"bottom-right\");\n\n    if (type == \"padding\" || type == \"content\") {\n        var bt = getBorder(style, \"top\");\n        var br = getBorder(style, \"right\");\n        var bb = getBorder(style, \"bottom\");\n        var bl = getBorder(style, \"left\");\n        rTL.x -= bl.width; rTL.y -= bt.width;\n        rTR.x -= br.width; rTR.y -= bt.width;\n        rBR.x -= br.width; rBR.y -= bb.width;\n        rBL.x -= bl.width; rBL.y -= bb.width;\n        if (type == \"content\") {\n            var pt = parseFloat(getPropertyValue(style, \"padding-top\"));\n            var pr = parseFloat(getPropertyValue(style, \"padding-right\"));\n            var pb = parseFloat(getPropertyValue(style, \"padding-bottom\"));\n            var pl = parseFloat(getPropertyValue(style, \"padding-left\"));\n            rTL.x -= pl; rTL.y -= pt;\n            rTR.x -= pr; rTR.y -= pt;\n            rBR.x -= pr; rBR.y -= pb;\n            rBL.x -= pl; rBL.y -= pb;\n        }\n    }\n\n    if (typeof type == \"number\") {\n        rTL.x -= type; rTL.y -= type;\n        rTR.x -= type; rTR.y -= type;\n        rBR.x -= type; rBR.y -= type;\n        rBL.x -= type; rBL.y -= type;\n    }\n\n    return roundBox(box, rTL, rTR, rBR, rBL);\n}\n\n// Create a drawing.Path for a rounded rectangle.  Receives the\n// bounding box and the border-radiuses in CSS order (top-left,\n// top-right, bottom-right, bottom-left).  The radiuses must be\n// objects containing x (horiz. radius) and y (vertical radius).\nfunction roundBox(box, rTL0, rTR0, rBR0, rBL0) {\n    var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);\n    var rTL = tmp.tl;\n    var rTR = tmp.tr;\n    var rBR = tmp.br;\n    var rBL = tmp.bl;\n    var path = new Path({ fill: null, stroke: null });\n    path.moveTo(box.left, box.top + rTL.y);\n    if (rTL.x) {\n        addArcToPath(path, box.left + rTL.x, box.top + rTL.y, {\n            startAngle: -180,\n            endAngle: -90,\n            radiusX: rTL.x,\n            radiusY: rTL.y\n        });\n    }\n    path.lineTo(box.right - rTR.x, box.top);\n    if (rTR.x) {\n        addArcToPath(path, box.right - rTR.x, box.top + rTR.y, {\n            startAngle: -90,\n            endAngle: 0,\n            radiusX: rTR.x,\n            radiusY: rTR.y\n        });\n    }\n    path.lineTo(box.right, box.bottom - rBR.y);\n    if (rBR.x) {\n        addArcToPath(path, box.right - rBR.x, box.bottom - rBR.y, {\n            startAngle: 0,\n            endAngle: 90,\n            radiusX: rBR.x,\n            radiusY: rBR.y\n        });\n    }\n    path.lineTo(box.left + rBL.x, box.bottom);\n    if (rBL.x) {\n        addArcToPath(path, box.left + rBL.x, box.bottom - rBL.y, {\n            startAngle: 90,\n            endAngle: 180,\n            radiusX: rBL.x,\n            radiusY: rBL.y\n        });\n    }\n    return path.close();\n}\n\nfunction formatCounter(val, style) {\n    var str = String(parseFloat(val));\n    switch (style) {\n      case \"decimal-leading-zero\":\n        if (str.length < 2) {\n            str = \"0\" + str;\n        }\n        return str;\n      case \"lower-roman\":\n        return arabicToRoman(val).toLowerCase();\n      case \"upper-roman\":\n        return arabicToRoman(val).toUpperCase();\n      case \"lower-latin\":\n      case \"lower-alpha\":\n        return alphaNumeral(val - 1);\n      case \"upper-latin\":\n      case \"upper-alpha\":\n        return alphaNumeral(val - 1).toUpperCase();\n      default:\n        return str;\n    }\n}\n\nfunction evalPseudoElementContent(element, content) {\n    function displayCounter(name, style, separator) {\n        if (!separator) {\n            return formatCounter(getCounter(name) || 0, style);\n        }\n        separator = separator.replace(/^\\s*([\"'])(.*)\\1\\s*$/, \"$2\");\n        return getAllCounters(name).map(function(val){\n            return formatCounter(val, style);\n        }).join(separator);\n    }\n    var a = splitProperty(content, /^\\s+/);\n    var result = [], m;\n    a.forEach(function(el){\n        var tmp;\n        if ((m = /^\\s*([\"'])(.*)\\1\\s*$/.exec(el))) {\n            result.push(m[2].replace(/\\\\([0-9a-f]{4})/gi, function(s, p){\n                return String.fromCharCode(parseInt(p, 16));\n            }));\n        }\n        else if ((m = /^\\s*counter\\((.*?)\\)\\s*$/.exec(el))) {\n            tmp = splitProperty(m[1]);\n            result.push(displayCounter(tmp[0], tmp[1]));\n        }\n        else if ((m = /^\\s*counters\\((.*?)\\)\\s*$/.exec(el))) {\n            tmp = splitProperty(m[1]);\n            result.push(displayCounter(tmp[0], tmp[2], tmp[1]));\n        }\n        else if ((m = /^\\s*attr\\((.*?)\\)\\s*$/.exec(el))) {\n            result.push(element.getAttribute(m[1]) || \"\");\n        }\n        else {\n            result.push(el);\n        }\n    });\n    return result.join(\"\");\n}\n\nfunction getCssText(style) {\n    if (style.cssText) {\n        return style.cssText;\n    }\n    // Status: NEW.  Report year: 2002.  Current year: 2014.\n    // Nice played, Mozillians.\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=137687\n    var result = [];\n    for (var i = 0; i < style.length; ++i) {\n        result.push(style[i] + \": \" + getPropertyValue(style, style[i]));\n    }\n    return result.join(\";\\n\");\n}\n\nfunction _renderWithPseudoElements(element, group) {\n    if (element.tagName == KENDO_PSEUDO_ELEMENT) {\n        _renderElement(element, group);\n        return;\n    }\n    var fake = [];\n    function pseudo(kind, place) {\n        var style = getComputedStyle(element, kind), content = style.content;\n        updateCounters(style);\n        if (content && content != \"normal\" && content != \"none\" && style.width != \"0px\") {\n            var psel = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);\n            psel.style.cssText = getCssText(style);\n            psel.textContent = evalPseudoElementContent(element, content);\n            element.insertBefore(psel, place);\n            fake.push(psel);\n        }\n    }\n    pseudo(\":before\", element.firstChild);\n    pseudo(\":after\", null);\n    if (fake.length > 0) {\n        var saveClass = element.className;\n        element.className += \" kendo-pdf-hide-pseudo-elements\";\n        _renderElement(element, group);\n        element.className = saveClass;\n        fake.forEach(function(el){ element.removeChild(el); });\n    } else {\n        _renderElement(element, group);\n    }\n}\n\nfunction _renderElement(element, group) {\n    var style = getComputedStyle(element);\n\n    var top = getBorder(style, \"top\");\n    var right = getBorder(style, \"right\");\n    var bottom = getBorder(style, \"bottom\");\n    var left = getBorder(style, \"left\");\n\n    var rTL0 = getBorderRadius(style, \"top-left\");\n    var rTR0 = getBorderRadius(style, \"top-right\");\n    var rBL0 = getBorderRadius(style, \"bottom-left\");\n    var rBR0 = getBorderRadius(style, \"bottom-right\");\n\n    var dir = getPropertyValue(style, \"direction\");\n\n    var backgroundColor = getPropertyValue(style, \"background-color\");\n    backgroundColor = parseColor(backgroundColor);\n\n    var backgroundImage = parseBackgroundImage( getPropertyValue(style, \"background-image\") );\n    var backgroundRepeat = splitProperty( getPropertyValue(style, \"background-repeat\") );\n    var backgroundPosition = splitProperty( getPropertyValue(style, \"background-position\") );\n    var backgroundOrigin = splitProperty( getPropertyValue(style, \"background-origin\") );\n    var backgroundSize = splitProperty( getPropertyValue(style, \"background-size\") );\n\n    // IE shrinks the text with text-overflow: ellipsis,\n    // apparently because the returned bounding box for the range\n    // is limited to the visible area minus space for the dots,\n    // instead of being the full width of the text.\n    //\n    // https://github.com/telerik/kendo/issues/5232\n    // https://github.com/telerik/kendo-ui-core/issues/1868\n    //\n    // We have to test it here rather than in renderText because\n    // text-overflow: ellipsis could be set on a parent element (not\n    // necessarily the one containing the text); in this case,\n    // getComputedStyle(elementWithTheText) will return \"clip\", not\n    // \"ellipsis\" (which is probably a bug, but oh well...)\n    var textOverflow, saveTextOverflow;\n    if (microsoft) {\n        textOverflow = style.textOverflow;             // computed style\n        if (textOverflow == \"ellipsis\") {\n            saveTextOverflow = element.style.textOverflow; // own style.\n            element.style.textOverflow = \"clip\";\n        }\n    }\n\n    if (browser.msie && browser.version < 10) {\n        // IE9 hacks.  getPropertyValue won't return the correct\n        // value.  Sucks that we have to do it here, I'd prefer to\n        // move it in getPropertyValue, but we don't have the\n        // element.\n        backgroundPosition = splitProperty(element.currentStyle.backgroundPosition);\n    }\n\n    var innerbox = innerBox(element.getBoundingClientRect(), \"border-*-width\", element);\n\n    // CSS \"clip\" property - if present, replace the group with a\n    // new one which is clipped.  This must happen before drawing\n    // the borders and background.\n    (function(){\n        var clip = getPropertyValue(style, \"clip\");\n        var m = /^\\s*rect\\((.*)\\)\\s*$/.exec(clip);\n        if (m) {\n            var a = m[1].split(/[ ,]+/g);\n            var top = a[0] == \"auto\" ? innerbox.top : parseFloat(a[0]) + innerbox.top;\n            var right = a[1] == \"auto\" ? innerbox.right : parseFloat(a[1]) + innerbox.left;\n            var bottom = a[2] == \"auto\" ? innerbox.bottom : parseFloat(a[2]) + innerbox.top;\n            var left = a[3] == \"auto\" ? innerbox.left : parseFloat(a[3]) + innerbox.left;\n            var tmp = new Group();\n            var clipPath = new Path()\n                .moveTo(left, top)\n                .lineTo(right, top)\n                .lineTo(right, bottom)\n                .lineTo(left, bottom)\n                .close();\n            setClipping(tmp, clipPath);\n            group.append(tmp);\n            group = tmp;\n            updateClipbox(clipPath);\n        }\n    })();\n\n    var boxes, i, cells;\n    var display = getPropertyValue(style, \"display\");\n\n    if (display == \"table-row\") {\n        // because of rowspan/colspan, we shouldn't draw background of table row elements on the\n        // box given by its getBoundingClientRect, because if we do we risk overwritting a\n        // previously rendered cell.  https://github.com/telerik/kendo/issues/4881\n        boxes = [];\n        for (i = 0, cells = element.children; i < cells.length; ++i) {\n            boxes.push(cells[i].getBoundingClientRect());\n        }\n    } else {\n        boxes = element.getClientRects();\n        if (boxes.length == 1) {\n            // Workaround the missing borders in Chrome!  getClientRects() boxes contains values\n            // rounded to integer.  getBoundingClientRect() appears to work fine.  We still need\n            // getClientRects() to support cases where there are more boxes (continued inline\n            // elements that might have border/background).\n            boxes = [ element.getBoundingClientRect() ];\n        }\n    }\n\n    // This function workarounds another Chrome bug, where boxes returned for a table with\n    // border-collapse: collapse will overlap the table border.  Our rendering is not perfect in\n    // such case anyway, but with this is better than without it.\n    boxes = adjustBoxes(boxes);\n\n    for (i = 0; i < boxes.length; ++i) {\n        drawOneBox(boxes[i], i === 0, i == boxes.length - 1);\n    }\n\n    // Render links as separate groups.  We can't use boxes returned by element's getClientRects\n    // because if display type is \"inline\" (default for <a>), boxes will not include the height of\n    // images inside.  https://github.com/telerik/kendo-ui-core/issues/3359\n    if (element.tagName == \"A\" && element.href && !/^#?$/.test(element.getAttribute(\"href\"))) {\n        if (!nodeInfo._avoidLinks || !matches(element, nodeInfo._avoidLinks)) {\n            var r = document.createRange();\n            r.selectNodeContents(element);\n            slice(r.getClientRects()).forEach(function(box){\n                var g = new Group();\n                g._pdfLink = {\n                    url    : element.href,\n                    top    : box.top,\n                    right  : box.right,\n                    bottom : box.bottom,\n                    left   : box.left\n                };\n                group.append(g);\n            });\n        }\n    }\n\n    if (boxes.length > 0 && display == \"list-item\" && !element.getAttribute(\"kendo-no-bullet\")) {\n        drawBullet(boxes[0]);\n    }\n\n    // overflow: hidden/auto - if present, replace the group with\n    // a new one clipped by the inner box.\n    (function(){\n        function clipit() {\n            var clipPath = elementRoundBox(element, innerbox, \"padding\");\n            var tmp = new Group();\n            setClipping(tmp, clipPath);\n            group.append(tmp);\n            group = tmp;\n            updateClipbox(clipPath);\n        }\n        if (isFormField(element)) {\n            clipit();\n        } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow\"))) {\n            clipit();\n        } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow-x\"))) {\n            clipit();\n        } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow-y\"))) {\n            clipit();\n        }\n    })();\n\n    if (!maybeRenderWidget(element, group)) {\n        renderContents(element, group);\n    }\n\n    if (microsoft && textOverflow == \"ellipsis\") {\n        element.style.textOverflow = saveTextOverflow;\n    }\n\n    return group; // only utility functions after this line.\n\n    function adjustBoxes(boxes) {\n        if (/^td$/i.test(element.tagName)) {\n            var table = nodeInfo.table;\n            if (table && getPropertyValue(table.style, \"border-collapse\") == \"collapse\") {\n                var tableBorderLeft = getBorder(table.style, \"left\").width;\n                var tableBorderTop = getBorder(table.style, \"top\").width;\n                // check if we need to adjust\n                if (tableBorderLeft === 0 && tableBorderTop === 0) {\n                    return boxes; // nope\n                }\n                var tableBox = table.element.getBoundingClientRect();\n                var firstCell = table.element.rows[0].cells[0];\n                var firstCellBox = firstCell.getBoundingClientRect();\n                if (firstCellBox.top == tableBox.top || firstCellBox.left == tableBox.left) {\n                    return slice(boxes).map(function(box){\n                        return {\n                            left   : box.left + tableBorderLeft,\n                            top    : box.top + tableBorderTop,\n                            right  : box.right + tableBorderLeft,\n                            bottom : box.bottom + tableBorderTop,\n                            height : box.height,\n                            width  : box.width\n                        };\n                    });\n                }\n            }\n        }\n        return boxes;\n    }\n\n    // this function will be called to draw each border.  it\n    // draws starting at origin and the resulted path must be\n    // translated/rotated to be placed in the proper position.\n    //\n    // arguments are named as if it draws the top border:\n    //\n    //    - `len` the length of the edge\n    //    - `Wtop` the width of the edge (i.e. border-top-width)\n    //    - `Wleft` the width of the left edge (border-left-width)\n    //    - `Wright` the width of the right edge\n    //    - `rl` and `rl` -- the border radius on the left and right\n    //      (objects containing x and y, for horiz/vertical radius)\n    //    - `transform` -- transformation to apply\n    //\n    function drawEdge(color, len, Wtop, Wleft, Wright, rl, rr, transform) {\n        if (Wtop <= 0) {\n            return;\n        }\n\n        var path, edge = new Group();\n        setTransform(edge, transform);\n        group.append(edge);\n\n        sanitizeRadius(rl);\n        sanitizeRadius(rr);\n\n        // draw main border.  this is the area without the rounded corners\n        path = new Path({\n            fill: { color: color },\n            stroke: null\n        });\n        edge.append(path);\n        path.moveTo(rl.x ? Math.max(rl.x, Wleft) : 0, 0)\n            .lineTo(len - (rr.x ? Math.max(rr.x, Wright) : 0), 0)\n            .lineTo(len - Math.max(rr.x, Wright), Wtop)\n            .lineTo(Math.max(rl.x, Wleft), Wtop)\n            .close();\n\n        if (rl.x) {\n            drawRoundCorner(Wleft, rl, [ -1, 0, 0, 1, rl.x, 0 ]);\n        }\n\n        if (rr.x) {\n            drawRoundCorner(Wright, rr, [ 1, 0, 0, 1, len - rr.x, 0 ]);\n        }\n\n        // draws one round corner, starting at origin (needs to be\n        // translated/rotated to be placed properly).\n        function drawRoundCorner(Wright, r, transform) {\n            var angle = Math.PI/2 * Wright / (Wright + Wtop);\n\n            // not sanitizing this one, because negative values\n            // are useful to fill the box correctly.\n            var ri = {\n                x: r.x - Wright,\n                y: r.y - Wtop\n            };\n\n            var path = new Path({\n                fill: { color: color },\n                stroke: null\n            }).moveTo(0, 0);\n\n            setTransform(path, transform);\n\n            addArcToPath(path, 0, r.y, {\n                startAngle: -90,\n                endAngle: -radiansToDegrees(angle),\n                radiusX: r.x,\n                radiusY: r.y\n            });\n\n            if (ri.x > 0 && ri.y > 0) {\n                path.lineTo(ri.x * Math.cos(angle), r.y - ri.y * Math.sin(angle));\n                addArcToPath(path, 0, r.y, {\n                    startAngle: -radiansToDegrees(angle),\n                    endAngle: -90,\n                    radiusX: ri.x,\n                    radiusY: ri.y,\n                    anticlockwise: true\n                });\n            }\n            else if (ri.x > 0) {\n                path.lineTo(ri.x, Wtop)\n                    .lineTo(0, Wtop);\n            }\n            else {\n                path.lineTo(ri.x, Wtop)\n                    .lineTo(ri.x, 0);\n            }\n\n            edge.append(path.close());\n        }\n    }\n\n    function drawBackground(box) {\n        var background = new Group();\n        setClipping(background, roundBox(box, rTL0, rTR0, rBR0, rBL0));\n        group.append(background);\n\n        if (backgroundColor) {\n            var path = new Path({\n                fill: { color: backgroundColor.toCssRgba() },\n                stroke: null\n            });\n            path.moveTo(box.left, box.top)\n                .lineTo(box.right, box.top)\n                .lineTo(box.right, box.bottom)\n                .lineTo(box.left, box.bottom)\n                .close();\n            background.append(path);\n        }\n\n        for (var i = backgroundImage.length; --i >= 0;) {\n            drawOneBackground(\n                background, box,\n                backgroundImage[i],\n                backgroundRepeat[i % backgroundRepeat.length],\n                backgroundPosition[i % backgroundPosition.length],\n                backgroundOrigin[i % backgroundOrigin.length],\n                backgroundSize[i % backgroundSize.length]\n            );\n        }\n    }\n\n    function drawOneBackground(group, box, background, backgroundRepeat, backgroundPosition, backgroundOrigin, backgroundSize) {\n        if (!background || (background == \"none\")) {\n            return;\n        }\n\n        if (background.type == \"url\") {\n            var img = IMAGE_CACHE[background.url];\n            if (img && img.width > 0 && img.height > 0) {\n                drawBackgroundImage(group, box, img.width, img.height, function(group, rect){\n                    group.append(new Image(background.url, rect));\n                });\n            }\n        } else if (background.type == \"linear\") {\n            drawBackgroundImage(group, box, box.width, box.height, gradientRenderer(background));\n        } else {\n            return;\n        }\n\n        function drawBackgroundImage(group, box, img_width, img_height, renderBG) {\n            var aspect_ratio = img_width / img_height, f;\n\n            // for background-origin: border-box the box is already appropriate\n            var orgBox = box;\n            if (backgroundOrigin == \"content-box\") {\n                orgBox = innerBox(orgBox, \"border-*-width\", element);\n                orgBox = innerBox(orgBox, \"padding-*\", element);\n            } else if (backgroundOrigin == \"padding-box\") {\n                orgBox = innerBox(orgBox, \"border-*-width\", element);\n            }\n\n            if (!/^\\s*auto(\\s+auto)?\\s*$/.test(backgroundSize)) {\n                if (backgroundSize == \"contain\") {\n                    f = Math.min(orgBox.width / img_width,\n                                 orgBox.height / img_height);\n                    img_width *= f;\n                    img_height *= f;\n                }\n                else if (backgroundSize == \"cover\") {\n                    f = Math.max(orgBox.width / img_width,\n                                 orgBox.height / img_height);\n                    img_width *= f;\n                    img_height *= f;\n                }\n                else {\n                    var size = backgroundSize.split(/\\s+/g);\n                    // compute width\n                    if (/%$/.test(size[0])) {\n                        img_width = orgBox.width * parseFloat(size[0]) / 100;\n                    } else {\n                        img_width = parseFloat(size[0]);\n                    }\n                    // compute height\n                    if (size.length == 1 || size[1] == \"auto\") {\n                        img_height = img_width / aspect_ratio;\n                    } else if (/%$/.test(size[1])) {\n                        img_height = orgBox.height * parseFloat(size[1]) / 100;\n                    } else {\n                        img_height = parseFloat(size[1]);\n                    }\n                }\n            }\n\n            var pos = String(backgroundPosition);\n\n            // IE sometimes reports single-word positions\n            // https://github.com/telerik/kendo-ui-core/issues/2786\n            //\n            // it seems to switch to percentages when the horizontal\n            // position is not \"center\", therefore we don't handle\n            // multi-word cases here.  All other browsers return\n            // percentages or pixels instead of keywords.  At least\n            // for now...\n            switch (pos) {\n              case \"bottom\" : pos = \"50% 100%\"; break;\n              case \"top\"    : pos = \"50% 0\"; break;\n              case \"left\"   : pos = \"0 50%\"; break;\n              case \"right\"  : pos = \"100% 50%\"; break;\n              case \"center\" : pos = \"50% 50%\"; break;\n            }\n\n            pos = pos.split(/\\s+/);\n            if (pos.length == 1) {\n                pos[1] = \"50%\";\n            }\n\n            if (/%$/.test(pos[0])) {\n                pos[0] = parseFloat(pos[0]) / 100 * (orgBox.width - img_width);\n            } else {\n                pos[0] = parseFloat(pos[0]);\n            }\n            if (/%$/.test(pos[1])) {\n                pos[1] = parseFloat(pos[1]) / 100 * (orgBox.height - img_height);\n            } else {\n                pos[1] = parseFloat(pos[1]);\n            }\n\n            var rect = new geo.Rect([ orgBox.left + pos[0], orgBox.top + pos[1] ], [ img_width, img_height ]);\n\n            // XXX: background-repeat could be implemented more\n            //      efficiently as a fill pattern (at least for PDF\n            //      output, probably SVG too).\n\n            function rewX() {\n                while (rect.origin.x > box.left) {\n                    rect.origin.x -= img_width;\n                }\n            }\n\n            function rewY() {\n                while (rect.origin.y > box.top) {\n                    rect.origin.y -= img_height;\n                }\n            }\n\n            function repeatX() {\n                while (rect.origin.x < box.right) {\n                    renderBG(group, rect.clone());\n                    rect.origin.x += img_width;\n                }\n            }\n\n            if (backgroundRepeat == \"no-repeat\") {\n                renderBG(group, rect);\n            }\n            else if (backgroundRepeat == \"repeat-x\") {\n                rewX();\n                repeatX();\n            }\n            else if (backgroundRepeat == \"repeat-y\") {\n                rewY();\n                while (rect.origin.y < box.bottom) {\n                    renderBG(group, rect.clone());\n                    rect.origin.y += img_height;\n                }\n            }\n            else if (backgroundRepeat == \"repeat\") {\n                rewX();\n                rewY();\n                var origin = rect.origin.clone();\n                while (rect.origin.y < box.bottom) {\n                    rect.origin.x = origin.x;\n                    repeatX();\n                    rect.origin.y += img_height;\n                }\n            }\n        }\n    }\n\n    function drawBullet() {\n        var listStyleType = getPropertyValue(style, \"list-style-type\");\n        if (listStyleType == \"none\") {\n            return;\n        }\n        var listStylePosition = getPropertyValue(style, \"list-style-position\");\n\n        function _drawBullet(f) {\n            saveStyle(element, function(){\n                element.style.position = \"relative\";\n                var bullet = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);\n                bullet.style.position = \"absolute\";\n                bullet.style.boxSizing = \"border-box\";\n                if (listStylePosition == \"outside\") {\n                    bullet.style.width = \"6em\";\n                    bullet.style.left = \"-6.8em\";\n                    bullet.style.textAlign = \"right\";\n                } else {\n                    bullet.style.left = \"0px\";\n                }\n                f(bullet);\n                element.insertBefore(bullet, element.firstChild);\n                renderElement(bullet, group);\n                element.removeChild(bullet);\n            });\n        }\n\n        function elementIndex(f) {\n            var a = element.parentNode.children;\n            var k = element.getAttribute(\"kendo-split-index\");\n            if (k != null) {\n                return f(k|0, a.length);\n            }\n            for (var i = 0; i < a.length; ++i) {\n                if (a[i] === element) {\n                    return f(i, a.length);\n                }\n            }\n        }\n\n        switch (listStyleType) {\n          case \"circle\":\n          case \"disc\":\n          case \"square\":\n            _drawBullet(function(bullet){\n                // XXX: the science behind these values is called \"trial and error\".\n                bullet.style.fontSize = \"60%\";\n                bullet.style.lineHeight = \"200%\";\n                bullet.style.paddingRight = \"0.5em\";\n                bullet.style.fontFamily = \"DejaVu Serif\";\n                bullet.innerHTML = {\n                    \"disc\"   : \"\\u25cf\",\n                    \"circle\" : \"\\u25ef\",\n                    \"square\" : \"\\u25a0\"\n                }[listStyleType];\n            });\n            break;\n\n          case \"decimal\":\n          case \"decimal-leading-zero\":\n            _drawBullet(function(bullet){\n                elementIndex(function(idx){\n                    ++idx;\n                    if (listStyleType == \"decimal-leading-zero\" && idx < 10) {\n                        idx = \"0\" + idx;\n                    }\n                    bullet.innerHTML = idx + \".\";\n                });\n            });\n            break;\n\n          case \"lower-roman\":\n          case \"upper-roman\":\n            _drawBullet(function(bullet){\n                elementIndex(function(idx){\n                    idx = arabicToRoman(idx + 1);\n                    if (listStyleType == \"upper-roman\") {\n                        idx = idx.toUpperCase();\n                    }\n                    bullet.innerHTML = idx + \".\";\n                });\n            });\n            break;\n\n          case \"lower-latin\":\n          case \"lower-alpha\":\n          case \"upper-latin\":\n          case \"upper-alpha\":\n            _drawBullet(function(bullet){\n                elementIndex(function(idx){\n                    idx = alphaNumeral(idx);\n                    if (/^upper/i.test(listStyleType)) {\n                        idx = idx.toUpperCase();\n                    }\n                    bullet.innerHTML = idx + \".\";\n                });\n            });\n            break;\n        }\n    }\n\n    // draws a single border box\n    function drawOneBox(box, isFirst, isLast) {\n        if (box.width === 0 || box.height === 0) {\n            return;\n        }\n\n        drawBackground(box);\n\n        var shouldDrawLeft = (left.width > 0 && ((isFirst && dir == \"ltr\") || (isLast && dir == \"rtl\")));\n        var shouldDrawRight = (right.width > 0 && ((isLast && dir == \"ltr\") || (isFirst && dir == \"rtl\")));\n\n        // The most general case is that the 4 borders have different widths and border\n        // radiuses.  The way that is handled is by drawing 3 Paths for each border: the\n        // straight line, and two round corners which represent half of the entire rounded\n        // corner.  To simplify code those shapes are drawed at origin (by the drawEdge\n        // function), then translated/rotated into the right position.\n        //\n        // However, this leads to poor results due to rounding in the simpler cases where\n        // borders are straight lines.  Therefore we handle a few such cases separately with\n        // straight lines. C^wC^wC^w -- nope, scratch that.  poor rendering was because of a bug\n        // in Chrome (getClientRects() returns rounded integer values rather than exact floats.\n        // web dev is still a ghetto.)\n\n        // first, just in case there is no border...\n        if (top.width === 0 && left.width === 0 && right.width === 0 && bottom.width === 0) {\n            return;\n        }\n\n        // START paint borders\n        // if all borders have equal colors...\n        if (top.color == right.color && top.color == bottom.color && top.color == left.color) {\n\n            // if same widths too, we can draw the whole border by stroking a single path.\n            if (top.width == right.width && top.width == bottom.width && top.width == left.width)\n            {\n                if (shouldDrawLeft && shouldDrawRight) {\n                    // reduce box by half the border width, so we can draw it by stroking.\n                    box = innerBox(box, top.width/2);\n\n                    // adjust the border radiuses, again by top.width/2, and make the path element.\n                    var path = elementRoundBox(element, box, top.width/2);\n                    path.options.stroke = {\n                        color: top.color,\n                        width: top.width\n                    };\n                    group.append(path);\n                    return;\n                }\n            }\n        }\n\n        // if border radiuses are zero and widths are at most one pixel, we can again use simple\n        // paths.\n        if (rTL0.x === 0 && rTR0.x === 0 && rBR0.x === 0 && rBL0.x === 0) {\n            // alright, 1.9px will do as well.  the difference in color blending should not be\n            // noticeable.\n            if (top.width < 2 && left.width < 2 && right.width < 2 && bottom.width < 2) {\n                // top border\n                if (top.width > 0) {\n                    group.append(\n                        new Path({\n                            stroke: { width: top.width, color: top.color }\n                        })\n                            .moveTo(box.left, box.top + top.width/2)\n                            .lineTo(box.right, box.top + top.width/2)\n                    );\n                }\n\n                // bottom border\n                if (bottom.width > 0) {\n                    group.append(\n                        new Path({\n                            stroke: { width: bottom.width, color: bottom.color }\n                        })\n                            .moveTo(box.left, box.bottom - bottom.width/2)\n                            .lineTo(box.right, box.bottom - bottom.width/2)\n                    );\n                }\n\n                // left border\n                if (shouldDrawLeft) {\n                    group.append(\n                        new Path({\n                            stroke: { width: left.width, color: left.color }\n                        })\n                            .moveTo(box.left + left.width/2, box.top)\n                            .lineTo(box.left + left.width/2, box.bottom)\n                    );\n                }\n\n                // right border\n                if (shouldDrawRight) {\n                    group.append(\n                        new Path({\n                            stroke: { width: right.width, color: right.color }\n                        })\n                            .moveTo(box.right - right.width/2, box.top)\n                            .lineTo(box.right - right.width/2, box.bottom)\n                    );\n                }\n\n                return;\n            }\n        }\n        // END paint borders\n\n        var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);\n        var rTL = tmp.tl;\n        var rTR = tmp.tr;\n        var rBR = tmp.br;\n        var rBL = tmp.bl;\n\n        // top border\n        drawEdge(top.color,\n                 box.width, top.width, left.width, right.width,\n                 rTL, rTR,\n                 [ 1, 0, 0, 1, box.left, box.top ]);\n\n        // bottom border\n        drawEdge(bottom.color,\n                 box.width, bottom.width, right.width, left.width,\n                 rBR, rBL,\n                 [ -1, 0, 0, -1, box.right, box.bottom ]);\n\n        // for left/right borders we need to invert the border-radiuses\n        function inv(p) {\n            return { x: p.y, y: p.x };\n        }\n\n        // left border\n        drawEdge(left.color,\n                 box.height, left.width, bottom.width, top.width,\n                 inv(rBL), inv(rTL),\n                 [ 0, -1, 1, 0, box.left, box.bottom ]);\n\n        // right border\n        drawEdge(right.color,\n                 box.height, right.width, top.width, bottom.width,\n                 inv(rTR), inv(rBR),\n                 [ 0, 1, -1, 0, box.right, box.top ]);\n    }\n}\n\nfunction gradientRenderer(gradient) {\n    return function(group, rect) {\n        var width = rect.width(), height = rect.height();\n\n        switch (gradient.type) {\n          case \"linear\":\n\n            // figure out the angle.\n            var angle = gradient.angle != null ? gradient.angle : Math.PI;\n            switch (gradient.to) {\n              case \"top\":\n                angle = 0;\n                break;\n              case \"left\":\n                angle = -Math.PI / 2;\n                break;\n              case \"bottom\":\n                angle = Math.PI;\n                break;\n              case \"right\":\n                angle = Math.PI / 2;\n                break;\n              case \"top left\": case \"left top\":\n                angle = -Math.atan2(height, width);\n                break;\n              case \"top right\": case \"right top\":\n                angle = Math.atan2(height, width);\n                break;\n              case \"bottom left\": case \"left bottom\":\n                angle = Math.PI + Math.atan2(height, width);\n                break;\n              case \"bottom right\": case \"right bottom\":\n                angle = Math.PI - Math.atan2(height, width);\n                break;\n            }\n\n            if (gradient.reverse) {\n                angle -= Math.PI;\n            }\n\n            // limit the angle between 0..2PI\n            angle %= 2 * Math.PI;\n            if (angle < 0) {\n                angle += 2 * Math.PI;\n            }\n\n            // compute gradient's start/end points.  here len is the length of the gradient line\n            // and x,y is the end point relative to the center of the rectangle in conventional\n            // (math) axis direction.\n\n            // this is the original (unscaled) length of the gradient line.  needed to deal with\n            // absolutely positioned color stops.  formula from the CSS spec:\n            // http://dev.w3.org/csswg/css-images-3/#linear-gradient-syntax\n            var pxlen = Math.abs(width * Math.sin(angle)) + Math.abs(height * Math.cos(angle));\n\n            // The math below is pretty simple, but it took a while to figure out.  We compute x\n            // and y, the *end* of the gradient line.  However, we want to transform them into\n            // element-based coordinates (SVG's gradientUnits=\"objectBoundingBox\").  That means,\n            // x=0 is the left edge, x=1 is the right edge, y=0 is the top edge and y=1 is the\n            // bottom edge.\n            //\n            // A naive approach would use the original angle for these calculations.  Say we'd\n            // like to draw a gradient angled at 45deg in a 100x400 box.  When we use\n            // objectBoundingBox, the renderer will draw it in a 1x1 *square* box, and then\n            // scale that to the desired dimensions.  The 45deg angle will look more like 70deg\n            // after scaling.  SVG (http://www.w3.org/TR/SVG/pservers.html#LinearGradients) says\n            // the following:\n            //\n            //     When gradientUnits=\"objectBoundingBox\" and 'gradientTransform' is the\n            //     identity matrix, the normal of the linear gradient is perpendicular to the\n            //     gradient vector in object bounding box space (i.e., the abstract coordinate\n            //     system where (0,0) is at the top/left of the object bounding box and (1,1) is\n            //     at the bottom/right of the object bounding box). When the object's bounding\n            //     box is not square, the gradient normal which is initially perpendicular to\n            //     the gradient vector within object bounding box space may render\n            //     non-perpendicular relative to the gradient vector in user space. If the\n            //     gradient vector is parallel to one of the axes of the bounding box, the\n            //     gradient normal will remain perpendicular. This transformation is due to\n            //     application of the non-uniform scaling transformation from bounding box space\n            //     to user space.\n            //\n            // which is an extremely long and confusing way to tell what I just said above.\n            //\n            // For this reason we need to apply the reverse scaling to the original angle, so\n            // that when it'll finally be rendered it'll actually be at the desired slope.  Now\n            // I'll let you figure out the math yourself.\n\n            var scaledAngle = Math.atan(width * Math.tan(angle) / height);\n            var sin = Math.sin(scaledAngle), cos = Math.cos(scaledAngle);\n            var len = Math.abs(sin) + Math.abs(cos);\n            var x = len/2 * sin;\n            var y = len/2 * cos;\n\n            // Because of the arctangent, our scaledAngle ends up between -PI/2..PI/2, possibly\n            // losing the intended direction of the gradient.  The following fixes it.\n            if (angle > Math.PI/2 && angle <= 3*Math.PI/2) {\n                x = -x;\n                y = -y;\n            }\n\n            // compute the color stops.\n            var implicit = [], right = 0;\n            var stops = gradient.stops.map(function(s, i){\n                var offset = s.percent;\n                if (offset) {\n                    offset = parseFloat(offset) / 100;\n                } else if (s.length) {\n                    offset = parseFloat(s.length) / pxlen;\n                } else if (i === 0) {\n                    offset = 0;\n                } else if (i == gradient.stops.length - 1) {\n                    offset = 1;\n                }\n                var stop = {\n                    color: s.color.toCssRgba(),\n                    offset: offset\n                };\n                if (offset != null) {\n                    right = offset;\n                    // fix implicit offsets\n                    implicit.forEach(function(s, i){\n                        var stop = s.stop;\n                        stop.offset = s.left + (right - s.left) * (i + 1) / (implicit.length + 1);\n                    });\n                    implicit = [];\n                } else {\n                    implicit.push({ left: right, stop: stop });\n                }\n                return stop;\n            });\n\n            var start = [ 0.5 - x, 0.5 + y ];\n            var end = [ 0.5 + x, 0.5 - y ];\n\n            // finally, draw it.\n            group.append(\n                Path.fromRect(rect)\n                    .stroke(null)\n                    .fill(new LinearGradient({\n                        start     : start,\n                        end       : end,\n                        stops     : stops,\n                        userSpace : false\n                    }))\n            );\n            break;\n          case \"radial\":\n            // XXX:\n            if (window.console && window.console.log) {\n                window.console.log(\"Radial gradients are not yet supported in HTML renderer\");\n            }\n            break;\n        }\n    };\n}\n\nfunction maybeRenderWidget(element, group) {\n    var visual;\n\n    if (element._kendoExportVisual) {\n        visual = element._kendoExportVisual();\n    } else if (window.kendo && window.kendo.jQuery && element.getAttribute(window.kendo.attr(\"role\"))) {\n        var widget = window.kendo.widgetInstance(window.kendo.jQuery(element));\n        if (widget && (widget.exportDOMVisual || widget.exportVisual)) {\n            if (widget.exportDOMVisual) {\n                visual = widget.exportDOMVisual();\n            } else {\n                visual = widget.exportVisual();\n            }\n        }\n    }\n\n    if (!visual) {\n        return false;\n    }\n\n    var wrap = new Group();\n    wrap.children.push(visual);\n\n    var bbox = element.getBoundingClientRect();\n    wrap.transform(geo.transform().translate(bbox.left, bbox.top));\n\n    group.append(wrap);\n\n    return true;\n}\n\nfunction renderImage(element, url, group) {\n    var box = getContentBox(element);\n    var rect = new geo.Rect([ box.left, box.top ], [ box.width, box.height ]);\n    var image = new Image(url, rect);\n    setClipping(image, elementRoundBox(element, box, \"content\"));\n    group.append(image);\n}\n\nfunction zIndexSort(a, b) {\n    var sa = getComputedStyle(a);\n    var sb = getComputedStyle(b);\n    var za = parseFloat(getPropertyValue(sa, \"z-index\"));\n    var zb = parseFloat(getPropertyValue(sb, \"z-index\"));\n    var pa = getPropertyValue(sa, \"position\");\n    var pb = getPropertyValue(sb, \"position\");\n    if (isNaN(za) && isNaN(zb)) {\n        if ((/static|absolute/.test(pa)) && (/static|absolute/.test(pb))) {\n            return 0;\n        }\n        if (pa == \"static\") {\n            return -1;\n        }\n        if (pb == \"static\") {\n            return 1;\n        }\n        return 0;\n    }\n    if (isNaN(za)) {\n        return zb === 0 ? 0 : zb > 0 ? -1 : 1;\n    }\n    if (isNaN(zb)) {\n        return za === 0 ? 0 : za > 0 ? 1 : -1;\n    }\n    return parseFloat(za) - parseFloat(zb);\n}\n\nfunction isFormField(element) {\n    return /^(?:textarea|select|input)$/i.test(element.tagName);\n}\n\nfunction getSelectedOption(element) {\n    if (element.selectedOptions && element.selectedOptions.length > 0) {\n        return element.selectedOptions[0];\n    }\n    return element.options[element.selectedIndex];\n}\n\nfunction renderCheckbox(element, group) {\n    var style = getComputedStyle(element);\n    var color = getPropertyValue(style, \"color\");\n    var box = element.getBoundingClientRect();\n    if (element.type == \"checkbox\") {\n        group.append(\n            Path.fromRect(\n                new geo.Rect([ box.left+1, box.top+1 ],\n                             [ box.width-2, box.height-2 ])\n            ).stroke(color, 1)\n        );\n        if (element.checked) {\n            // fill a rectangle inside?  looks kinda ugly.\n            // group.append(\n            //     Path.fromRect(\n            //         new geo.Rect([ box.left+4, box.top+4 ],\n            //                      [ box.width-8, box.height-8])\n            //     ).fill(color).stroke(null)\n            // );\n\n            // let's draw a checkmark instead.  artistic, eh?\n            group.append(\n                new Path()\n                    .stroke(color, 1.2)\n                    .moveTo(box.left + 0.22 * box.width,\n                            box.top + 0.55 * box.height)\n                    .lineTo(box.left + 0.45 * box.width,\n                            box.top + 0.75 * box.height)\n                    .lineTo(box.left + 0.78 * box.width,\n                            box.top + 0.22 * box.width)\n            );\n        }\n    } else {\n        group.append(\n            new Circle(\n                new geo.Circle([\n                    (box.left + box.right) / 2,\n                    (box.top + box.bottom) / 2\n                ], Math.min(box.width-2, box.height-2) / 2)\n            ).stroke(color, 1)\n        );\n        if (element.checked) {\n            group.append(\n                new Circle(\n                    new geo.Circle([\n                        (box.left + box.right) / 2,\n                        (box.top + box.bottom) / 2\n                    ], Math.min(box.width-8, box.height-8) / 2)\n                ).fill(color).stroke(null)\n            );\n        }\n    }\n}\n\nfunction renderFormField(element, group) {\n    var tag = element.tagName.toLowerCase();\n    if (tag == \"input\" && (element.type == \"checkbox\" || element.type == \"radio\")) {\n        return renderCheckbox(element, group);\n    }\n    var p = element.parentNode;\n    var doc = element.ownerDocument;\n    var el = doc.createElement(KENDO_PSEUDO_ELEMENT);\n    var option;\n    el.style.cssText = getCssText(getComputedStyle(element));\n    if (tag == \"input\") {\n        el.style.whiteSpace = \"pre\";\n    }\n    if (tag == \"select\" || tag == \"textarea\") {\n        el.style.overflow = \"auto\";\n    }\n    if (tag == \"select\") {\n        if (element.multiple) {\n            for (var i = 0; i < element.options.length; ++i) {\n                option = doc.createElement(KENDO_PSEUDO_ELEMENT);\n                option.style.cssText = getCssText(getComputedStyle(element.options[i]));\n                option.style.display = \"block\"; // IE9 messes up without this\n                option.textContent = element.options[i].textContent;\n                el.appendChild(option);\n            }\n        } else {\n            option = getSelectedOption(element);\n            if (option) {\n                el.textContent = option.textContent;\n            }\n        }\n    } else {\n        el.textContent = element.value;\n    }\n    p.insertBefore(el, element);\n    el.scrollLeft = element.scrollLeft;\n    el.scrollTop = element.scrollTop;\n\n    // must temporarily hide the original element, otherwise it\n    // may affect layout of the fake element we want to render.\n    element.style.display = \"none\";\n\n    renderContents(el, group);\n    element.style.display = \"\";\n    p.removeChild(el);\n}\n\nfunction serializeSVG(element) {\n    var serializer = new window.XMLSerializer();\n    var xml = serializer.serializeToString(element);\n\n    if (browser.mozilla && !(element.getAttribute(\"width\") && element.getAttribute(\"height\"))) {\n        var doc = new window.DOMParser().parseFromString(xml, \"image/svg+xml\");\n        var svg = doc.documentElement;\n        var box = getContentBox(element);\n        svg.setAttribute(\"width\", box.width);\n        svg.setAttribute(\"height\", box.height);\n        xml = serializer.serializeToString(svg);\n    }\n\n    return xml;\n}\n\nfunction renderContents(element, group) {\n    if (nodeInfo._stackingContext.element === element) {\n        // the group that was set in pushNodeInfo might have\n        // changed due to clipping/transforms, update it here.\n        nodeInfo._stackingContext.group = group;\n    }\n    switch (element.tagName.toLowerCase()) {\n      case \"img\":\n        renderImage(element, element.src, group);\n        break;\n\n      case \"svg\":\n        var xml = serializeSVG(element);\n        var dataURL = \"data:image/svg+xml;base64,\" + (encodeBase64(xml));\n        renderImage(element, dataURL, group);\n        break;\n\n      case \"canvas\":\n        try {\n            renderImage(element, element.toDataURL(\"image/png\"), group);\n        } catch (ex) {\n            // tainted; can't draw it, ignore.\n        }\n        break;\n\n      case \"textarea\":\n      case \"input\":\n      case \"select\":\n        renderFormField(element, group);\n        break;\n\n      default:\n        var children = [], floats = [], positioned = [];\n        for (var i = element.firstChild; i; i = i.nextSibling) {\n            switch (i.nodeType) {\n              case 3:         // Text\n                if (/\\S/.test(i.data)) {\n                    renderText(element, i, group);\n                }\n                break;\n              case 1:         // Element\n                var style = getComputedStyle(i);\n                var floating = getPropertyValue(style, \"float\");\n                var position = getPropertyValue(style, \"position\");\n                if (position != \"static\") {\n                    positioned.push(i);\n                }\n                else if (floating != \"none\") {\n                    floats.push(i);\n                } else {\n                    children.push(i);\n                }\n                break;\n            }\n        }\n\n        mergeSort(children, zIndexSort).forEach(function(el){ renderElement(el, group); });\n        mergeSort(floats, zIndexSort).forEach(function(el){ renderElement(el, group); });\n        mergeSort(positioned, zIndexSort).forEach(function(el){ renderElement(el, group); });\n    }\n}\n\nfunction renderText(element, node, group) {\n    if (emptyClipbox()) {\n        return;\n    }\n    var style = getComputedStyle(element);\n\n    if (parseFloat(getPropertyValue(style, \"text-indent\")) < -500) {\n        // assume it should not be displayed.  the slider's\n        // draggable handle displays a Drag text for some reason,\n        // having text-indent: -3333px.\n        return;\n    }\n\n    var text = node.data;\n    var start = 0;\n    var end = text.search(/\\S\\s*$/) + 1;\n\n    if (!end) {\n        return; // whitespace-only node\n    }\n\n    var fontSize = getPropertyValue(style, \"font-size\");\n    var lineHeight = getPropertyValue(style, \"line-height\");\n\n    // simply getPropertyValue(\"font\") doesn't work in Firefox :-\\\n    var font = [\n        getPropertyValue(style, \"font-style\"),\n        getPropertyValue(style, \"font-variant\"),\n        getPropertyValue(style, \"font-weight\"),\n        fontSize, // no need for line height here; it breaks layout in FF\n        getPropertyValue(style, \"font-family\")\n    ].join(\" \");\n\n    fontSize = parseFloat(fontSize);\n    lineHeight = parseFloat(lineHeight);\n\n    if (fontSize === 0 || isNaN(fontSize)) {\n        return;\n    }\n\n    var color = getPropertyValue(style, \"color\");\n    var range = element.ownerDocument.createRange();\n    var align = getPropertyValue(style, \"text-align\");\n    var isJustified = align == \"justify\";\n    var columnCount = getPropertyValue(style, \"column-count\", 1);\n    var whiteSpace = getPropertyValue(style, \"white-space\");\n    var textTransform = getPropertyValue(style, \"text-transform\");\n\n    // A line of 500px, with a font of 12px, contains an average of 80 characters, but since we\n    // err, we'd like to guess a bigger number rather than a smaller one.  Multiplying by 5\n    // seems to be a good option.\n    var estimateLineLength = element.getBoundingClientRect().width / fontSize * 5;\n    if (estimateLineLength === 0) {\n        estimateLineLength = 500;\n    }\n\n    // we'll maintain this so we can workaround bugs in Chrome's Range.getClientRects\n    // https://github.com/telerik/kendo/issues/5740\n    var prevLineBottom = null;\n\n    var underline = nodeInfo[\"underline\"];\n    var lineThrough = nodeInfo[\"line-through\"];\n    var overline = nodeInfo[\"overline\"];\n    var underlineOffset = nodeInfo[\"underline-offset\"];\n\n    if (underline) {\n        forEachRect(decorateUnder);\n    }\n\n    // doChunk returns true when all text has been rendered\n    while (!doChunk()) {}\n\n    if (lineThrough || overline) {\n        forEachRect(decorateOver);\n    }\n\n    return;                 // only function declarations after this line\n\n    function forEachRect(callback) {\n        range.selectNode(node);\n        var clientRects = slice(range.getClientRects());\n\n        forEachRect = function (cb) { return clientRects.forEach(cb); };\n        forEachRect(callback);\n    }\n\n    function actuallyGetRangeBoundingRect(range) {\n        // XXX: to be revised when this Chrome bug is fixed:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=612459\n        if (microsoft || browser.chrome || browser.safari) {\n            // Workaround browser bugs: IE and Chrome would sometimes\n            // return 0 or 1-width rectangles before or after the main\n            // one.  https://github.com/telerik/kendo/issues/4674\n\n            // Actually Chrome 50 got worse, since the rectangles can now have the width of a\n            // full character, making it hard to tell whether it's a bogus rectangle or valid\n            // selection location.  The workaround is to ignore rectangles that fall on the\n            // previous line.  https://github.com/telerik/kendo/issues/5740\n            var rectangles = range.getClientRects(), box = {\n                top    :  Infinity,\n                right  : -Infinity,\n                bottom : -Infinity,\n                left   :  Infinity\n            }, done = false;\n            for (var i = 0; i < rectangles.length; ++i) {\n                var b = rectangles[i];\n                if (b.width <= 1 || b.bottom === prevLineBottom) {\n                    continue;   // bogus rectangle\n                }\n                box.left   = Math.min(b.left   , box.left);\n                box.top    = Math.min(b.top    , box.top);\n                box.right  = Math.max(b.right  , box.right);\n                box.bottom = Math.max(b.bottom , box.bottom);\n                done = true;\n            }\n            if (!done) {\n                return range.getBoundingClientRect();\n            }\n            box.width = box.right - box.left;\n            box.height = box.bottom - box.top;\n            return box;\n        }\n        return range.getBoundingClientRect();\n    }\n\n    // Render a chunk of text, typically one line (but for justified text we render each word as\n    // a separate Text object, because spacing is variable).  Returns true when it finished the\n    // current node.  After each chunk it updates `start` to just after the last rendered\n    // character.\n    function doChunk() {\n        var origStart = start;\n        var box, pos = text.substr(start).search(/\\S/);\n        start += pos;\n        if (pos < 0 || start >= end) {\n            return true;\n        }\n\n        // Select a single character to determine the height of a line of text.  The box.bottom\n        // will be essential for us to figure out where the next line begins.\n        range.setStart(node, start);\n        range.setEnd(node, start + 1);\n        box = actuallyGetRangeBoundingRect(range);\n\n        // for justified text we must split at each space, because space has variable width.\n        var found = false;\n        if (isJustified || columnCount > 1) {\n            pos = text.substr(start).search(/\\s/);\n            if (pos >= 0) {\n                // we can only split there if it's on the same line, otherwise we'll fall back\n                // to the default mechanism (see findEOL below).\n                range.setEnd(node, start + pos);\n                var r = actuallyGetRangeBoundingRect(range);\n                if (r.bottom == box.bottom) {\n                    box = r;\n                    found = true;\n                    start += pos;\n                }\n            }\n        }\n\n        if (!found) {\n            // This code does three things: (1) it selects one line of text in `range`, (2) it\n            // leaves the bounding rect of that line in `box` and (3) it returns the position\n            // just after the EOL.  We know where the line starts (`start`) but we don't know\n            // where it ends.  To figure this out, we select a piece of text and look at the\n            // bottom of the bounding box.  If it changes, we have more than one line selected\n            // and should retry with a smaller selection.\n            //\n            // To speed things up, we first try to select all text in the node (`start` ->\n            // `end`).  If there's more than one line there, then select only half of it.  And\n            // so on.  When we find a value for `end` that fits in one line, we try increasing\n            // it (also in halves) until we get to the next line.  The algorithm stops when the\n            // right side of the bounding box does not change.\n            //\n            // One more thing to note is that everything happens in a single Text DOM node.\n            // There's no other tags inside it, therefore the left/top coordinates of the\n            // bounding box will not change.\n            pos = (function findEOL(min, eol, max){\n                range.setEnd(node, eol);\n                var r = actuallyGetRangeBoundingRect(range);\n                if (r.bottom != box.bottom && min < eol) {\n                    return findEOL(min, (min + eol) >> 1, eol);\n                } else if (r.right != box.right) {\n                    box = r;\n                    if (eol < max) {\n                        return findEOL(eol, (eol + max) >> 1, max);\n                    } else {\n                        return eol;\n                    }\n                } else {\n                    return eol;\n                }\n            })(start, Math.min(end, start + estimateLineLength), end);\n\n            if (pos == start) {\n                // if EOL is at the start, then no more text fits on this line.  Skip the\n                // remainder of this node entirely to avoid a stack overflow.\n                return true;\n            }\n            start = pos;\n\n            pos = range.toString().search(/\\s+$/);\n            if (pos === 0) {\n                return false; // whitespace only; we should not get here.\n            }\n            if (pos > 0) {\n                // eliminate trailing whitespace\n                range.setEnd(node, range.startOffset + pos);\n                box = actuallyGetRangeBoundingRect(range);\n            }\n        }\n\n        // another workaround for IE: if we rely on getBoundingClientRect() we'll overlap with the bullet for LI\n        // elements.  Calling getClientRects() and using the *first* rect appears to give us the correct location.\n        // Note: not to be used in Chrome as it randomly returns a zero-width rectangle from the previous line.\n        if (microsoft) {\n            box = range.getClientRects()[0];\n        }\n\n        var str = range.toString();\n        if (!/^(?:pre|pre-wrap)$/i.test(whiteSpace)) {\n            // node with non-significant space -- collapse whitespace.\n            str = str.replace(/\\s+/g, \" \");\n        }\n        else if (/\\t/.test(str)) {\n            // with significant whitespace we need to do something about literal TAB characters.\n            // There's no TAB glyph in a font so they would be rendered in PDF as an empty box,\n            // and the whole text will stretch to fill the original width.  The core PDF lib\n            // does not have sufficient context to deal with it.\n\n            // calculate the starting column here, since we initially discarded any whitespace.\n            var cc = 0;\n            for (pos = origStart; pos < range.startOffset; ++pos) {\n                var code = text.charCodeAt(pos);\n                if (code == 9) {\n                    // when we meet a TAB we must round up to the next tab stop.\n                    // in all browsers TABs seem to be 8 characters.\n                    cc += 8 - cc % 8;\n                } else if (code == 10 || code == 13) {\n                    // just in case we meet a newline we must restart.\n                    cc = 0;\n                } else {\n                    // ordinary character --> advance one column\n                    cc++;\n                }\n            }\n\n            // based on starting column, replace any TAB characters in the string we actually\n            // have to display with spaces so that they align to columns multiple of 8.\n            while ((pos = str.search(\"\\t\")) >= 0) {\n                var indent = \"        \".substr(0, 8 - (cc + pos) % 8);\n                str = str.substr(0, pos) + indent + str.substr(pos + 1);\n            }\n        }\n\n        if (!found) {\n            prevLineBottom = box.bottom;\n        }\n        drawText(str, box);\n    }\n\n    function drawText(str, box) {\n        // In IE the box height will be approximately lineHeight, while in\n        // other browsers it'll (correctly) be the height of the bounding\n        // box for the current text/font.  Which is to say, IE sucks again.\n        // The only good solution I can think of is to measure the text\n        // ourselves and center the bounding box.\n        if (microsoft && !isNaN(lineHeight)) {\n            var height = getFontHeight(font);\n            var top = (box.top + box.bottom - height) / 2;\n            box = {\n                top    : top,\n                right  : box.right,\n                bottom : top + height,\n                left   : box.left,\n                height : height,\n                width  : box.right - box.left\n            };\n        }\n\n        // var path = new Path({ stroke: { color: \"red\" }});\n        // path.moveTo(box.left, box.top)\n        //     .lineTo(box.right, box.top)\n        //     .lineTo(box.right, box.bottom)\n        //     .lineTo(box.left, box.bottom)\n        //     .close();\n        // group.append(path);\n\n        switch (textTransform) {\n          case \"uppercase\":\n            str = str.toUpperCase();\n            break;\n          case \"lowercase\":\n            str = str.toLowerCase();\n            break;\n          case \"capitalize\":\n            str = str.replace(/(?:^|\\s)\\S/g, function (l) { return l.toUpperCase(); });\n            break;\n        }\n\n        var text = new TextRect(\n            str, new geo.Rect([ box.left, box.top ],\n                              [ box.width, box.height ]),\n            {\n                font: font,\n                fill: { color: color }\n            }\n        );\n        group.append(text);\n    }\n\n    function drawTextLine(lineWidth, textBox, color, ypos) {\n        if (color) {\n            var path = new Path({ stroke: {\n                width: lineWidth,\n                color: color\n            }});\n\n            ypos -= lineWidth;\n            path.moveTo(textBox.left, ypos)\n                .lineTo(textBox.right, ypos);\n            group.append(path);\n        }\n    }\n\n    function decorateOver(box) {\n        var width = fontSize / 12;\n        drawTextLine(width, box, lineThrough, box.bottom - box.height / 2.7);\n        drawTextLine(width, box, overline, box.top);\n    }\n\n    function decorateUnder(box) {\n        var width = fontSize / 12;\n        var underlinePos = box.bottom;\n        if (underlineOffset != null) {\n            underlinePos += underlineOffset;\n        } else {\n            underlinePos += width; // for \"auto\" it seems better to add line width\n        }\n        drawTextLine(width, box, underline, underlinePos);\n    }\n}\n\nfunction groupInStackingContext(element, group, zIndex) {\n    var main;\n    if (zIndex != \"auto\") {\n        // use the current stacking context\n        main = nodeInfo._stackingContext.group;\n        zIndex = parseFloat(zIndex);\n    } else {\n        // normal flow â€” use given container.  we still have to\n        // figure out where should we insert this element with the\n        // assumption that its z-index is zero, as the group might\n        // already contain elements with higher z-index.\n        main = group;\n        zIndex = 0;\n    }\n    var a = main.children;\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i]._dom_zIndex != null && a[i]._dom_zIndex > zIndex) {\n            break;\n        }\n    }\n\n    var tmp = new Group();\n    main.insert(i, tmp);\n    tmp._dom_zIndex = zIndex;\n\n    if (main !== group) {\n        // console.log(\"Placing\", element, \"in\", nodeInfo._stackingContext.element, \"at position\", i, \" / \", a.length);\n        // console.log(a.slice(i+1));\n\n        // if (nodeInfo._matrix) {\n        //     tmp.transform(nodeInfo._matrix);\n        // }\n        if (nodeInfo._clipbox) {\n            var m = nodeInfo._matrix.invert();\n            var r = nodeInfo._clipbox.transformCopy(m);\n            setClipping(tmp, Path.fromRect(r));\n            // console.log(r);\n            // tmp.append(Path.fromRect(r));\n            // tmp.append(new Text(element.className || element.id, r.topLeft()));\n        }\n    }\n\n    return tmp;\n}\n\nfunction renderElement(element, container) {\n    var style = getComputedStyle(element);\n\n    updateCounters(style);\n\n    if (/^(style|script|link|meta|iframe|col|colgroup)$/i.test(element.tagName)) {\n        return;\n    }\n\n    if (nodeInfo._clipbox == null) {\n        return;\n    }\n\n    var opacity = parseFloat(getPropertyValue(style, \"opacity\"));\n    var visibility = getPropertyValue(style, \"visibility\");\n    var display = getPropertyValue(style, \"display\");\n\n    if (opacity === 0 || visibility == \"hidden\" || display == \"none\") {\n        return;\n    }\n\n    var tr = getTransform(style);\n    var group;\n\n    var zIndex = getPropertyValue(style, \"z-index\");\n    if ((tr || opacity < 1) && zIndex == \"auto\") {\n        zIndex = 0;\n    }\n    group = groupInStackingContext(element, container, zIndex);\n\n    // XXX: remove at some point\n    // group._pdfElement = element;\n    // group.options._pdfDebug = \"\";\n    // if (element.id) {\n    //     group.options._pdfDebug = \"#\" + element.id;\n    // }\n    // if (element.className) {\n    //     group.options._pdfDebug += \".\" + element.className.split(\" \").join(\".\");\n    // }\n\n    if (opacity < 1) {\n        group.opacity(opacity * group.opacity());\n    }\n\n    pushNodeInfo(element, style, group);\n\n    if (!tr) {\n        _renderWithPseudoElements(element, group);\n    }\n    else {\n        saveStyle(element, function(){\n            // must clear transform, so getBoundingClientRect returns correct values.\n            pleaseSetPropertyValue(element.style, \"transform\", \"none\", \"important\");\n\n            // must also clear transitions, so correct values are returned *immediately*\n            pleaseSetPropertyValue(element.style, \"transition\", \"none\", \"important\");\n\n            // the presence of any transform makes it behave like it had position: relative,\n            // because why not.\n            // http://meyerweb.com/eric/thoughts/2011/09/12/un-fixing-fixed-elements-with-css-transforms/\n            if (getPropertyValue(style, \"position\") == \"static\") {\n                // but only if it's not already positioned. :-/\n                pleaseSetPropertyValue(element.style, \"position\", \"relative\", \"important\");\n            }\n\n            // must translate to origin before applying the CSS\n            // transformation, then translate back.\n            var bbox = element.getBoundingClientRect();\n            var x = bbox.left + tr.origin[0];\n            var y = bbox.top + tr.origin[1];\n            var m = [ 1, 0, 0, 1, -x, -y ];\n            m = mmul(m, tr.matrix);\n            m = mmul(m, [ 1, 0, 0, 1, x, y ]);\n            m = setTransform(group, m);\n\n            nodeInfo._matrix = nodeInfo._matrix.multiplyCopy(m);\n\n            _renderWithPseudoElements(element, group);\n        });\n    }\n\n    popNodeInfo();\n\n    //drawDebugBox(element.getBoundingClientRect(), container);\n}\n\n// function drawDebugBox(box, group, color) {\n//     var path = Path.fromRect(new geo.Rect([ box.left, box.top ], [ box.width, box.height ]));\n//     if (color) {\n//         path.stroke(color);\n//     }\n//     group.append(path);\n// }\n\n// function dumpTextNode(node) {\n//     var txt = node.data.replace(/^\\s+/, \"\");\n//     if (txt.length < 100) {\n//         console.log(node.data.length + \": |\" + txt);\n//     } else {\n//         console.log(node.data.length + \": |\" + txt.substr(0, 50) + \"|...|\" + txt.substr(-50));\n//     }\n// }\n\nfunction mmul(a, b) {\n    var a1 = a[0], b1 = a[1], c1 = a[2], d1 = a[3], e1 = a[4], f1 = a[5];\n    var a2 = b[0], b2 = b[1], c2 = b[2], d2 = b[3], e2 = b[4], f2 = b[5];\n    return [\n        a1*a2 + b1*c2,          a1*b2 + b1*d2,\n        c1*a2 + d1*c2,          c1*b2 + d1*d2,\n        e1*a2 + f1*c2 + e2,     e1*b2 + f1*d2 + f2\n    ];\n}\n\nexport { drawDOM, drawText, getFontFaces };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}